
GDR.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00000e34  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80003000  80003000  00003400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000001d8  80003200  80003200  00003600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         0000000c  00000004  800033d8  00003804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000000e8  00000010  800033e4  00003810  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  00003810  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000718  00000000  00000000  00003840  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000015db  00000000  00000000  00003f58  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000dd60  00000000  00000000  00005533  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000017cb  00000000  00000000  00013293  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00005fe4  00000000  00000000  00014a5e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000012c4  00000000  00000000  0001aa44  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00003de5  00000000  00000000  0001bd08  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00002f74  00000000  00000000  0001faed  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 0079aeef  00000000  00000000  00022a61  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00007000  00007000  00000400  2**0
                  ALLOC
 18 .debug_ranges 000006f0  00000000  00000000  007bd950  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	fe cf f5 68 	sub	pc,pc,-2712

Disassembly of section .text:

80002004 <flashcdw_set_wait_state>:
}


void flashcdw_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashcdw_fcr_t u_avr32_flashcdw_fcr = {AVR32_FLASHCDW.fcr};
80002004:	fe 68 00 00 	mov	r8,-131072
80002008:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashcdw_fcr.FCR.fws = wait_state;
8000200a:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHCDW.fcr = u_avr32_flashcdw_fcr.fcr;
8000200e:	91 09       	st.w	r8[0x0],r9
}
80002010:	5e fc       	retal	r12

80002012 <flashcdw_is_ready>:
//! @{


bool flashcdw_is_ready(void)
{
	return ((AVR32_FLASHCDW.fsr & AVR32_FLASHCDW_FSR_FRDY_MASK) != 0);
80002012:	fe 68 00 00 	mov	r8,-131072
80002016:	70 2c       	ld.w	r12,r8[0x8]
}
80002018:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
8000201c:	5e fc       	retal	r12
8000201e:	d7 03       	nop

80002020 <flashcdw_default_wait_until_ready>:


void flashcdw_default_wait_until_ready(void)
{
80002020:	d4 01       	pushm	lr
	while (!flashcdw_is_ready());
80002022:	f0 1f 00 03 	mcall	8000202c <flashcdw_default_wait_until_ready+0xc>
80002026:	cf e0       	breq	80002022 <flashcdw_default_wait_until_ready+0x2>
}
80002028:	d8 02       	popm	pc
8000202a:	00 00       	add	r0,r0
8000202c:	80 00       	ld.sh	r0,r0[0x0]
8000202e:	20 12       	sub	r2,1

80002030 <flashcdw_issue_command>:
	return (AVR32_FLASHCDW.fcmd & AVR32_FLASHCDW_FCMD_PAGEN_MASK) >> AVR32_FLASHCDW_FCMD_PAGEN_OFFSET;
}


void flashcdw_issue_command(unsigned int command, int page_number)
{
80002030:	eb cd 40 c0 	pushm	r6-r7,lr
80002034:	18 96       	mov	r6,r12
80002036:	16 97       	mov	r7,r11
	u_avr32_flashcdw_fcmd_t u_avr32_flashcdw_fcmd;

	flashcdw_wait_until_ready();
80002038:	48 e8       	lddpc	r8,80002070 <flashcdw_issue_command+0x40>
8000203a:	70 08       	ld.w	r8,r8[0x0]
8000203c:	5d 18       	icall	r8
	u_avr32_flashcdw_fcmd.fcmd = AVR32_FLASHCDW.fcmd;
8000203e:	fe 68 00 00 	mov	r8,-131072
80002042:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashcdw_fcmd.FCMD.cmd = command;
80002044:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
	if (page_number >= 0) {
80002048:	58 07       	cp.w	r7,0
8000204a:	c0 35       	brlt	80002050 <flashcdw_issue_command+0x20>
		u_avr32_flashcdw_fcmd.FCMD.pagen = page_number;
8000204c:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
	}
	u_avr32_flashcdw_fcmd.FCMD.key = AVR32_FLASHCDW_FCMD_KEY_KEY;
80002050:	3a 59       	mov	r9,-91
80002052:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHCDW.fcmd = u_avr32_flashcdw_fcmd.fcmd;
80002056:	fe 69 00 00 	mov	r9,-131072
8000205a:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashcdw_is_lock_error
 *          and \ref flashcdw_is_programming_error.
 */
static unsigned int flashcdw_get_error_status(void)
{
	return AVR32_FLASHCDW.fsr & (AVR32_FLASHCDW_FSR_LOCKE_MASK |
8000205c:	72 29       	ld.w	r9,r9[0x8]
	if (page_number >= 0) {
		u_avr32_flashcdw_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashcdw_fcmd.FCMD.key = AVR32_FLASHCDW_FCMD_KEY_KEY;
	AVR32_FLASHCDW.fcmd = u_avr32_flashcdw_fcmd.fcmd;
	flashcdw_error_status = flashcdw_get_error_status();
8000205e:	e2 19 00 0c 	andl	r9,0xc,COH
80002062:	48 58       	lddpc	r8,80002074 <flashcdw_issue_command+0x44>
80002064:	91 09       	st.w	r8[0x0],r9
	flashcdw_wait_until_ready();
80002066:	48 38       	lddpc	r8,80002070 <flashcdw_issue_command+0x40>
80002068:	70 08       	ld.w	r8,r8[0x0]
8000206a:	5d 18       	icall	r8
}
8000206c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002070:	00 00       	add	r0,r0
80002072:	00 04       	add	r4,r0
80002074:	00 00       	add	r0,r0
80002076:	00 10       	sub	r0,r0

80002078 <flashcdw_set_flash_waitstate_and_readmode>:
	AVR32_FLASHCDW.fcr = u_avr32_flashcdw_fcr.fcr;
}


void flashcdw_set_flash_waitstate_and_readmode(unsigned long cpu_f_hz)
{
80002078:	d4 01       	pushm	lr
	if (cpu_f_hz > AVR32_FLASHCDW_FWS_0_MAX_FREQ) { // > 15MHz
8000207a:	e0 68 e1 c0 	mov	r8,57792
8000207e:	ea 18 00 e4 	orh	r8,0xe4
80002082:	10 3c       	cp.w	r12,r8
80002084:	e0 88 00 19 	brls	800020b6 <flashcdw_set_flash_waitstate_and_readmode+0x3e>
		if (cpu_f_hz <= AVR32_FLASHCDW_FWS_1_MAX_FREQ) { // <= 30MHz
80002088:	e0 68 c3 80 	mov	r8,50048
8000208c:	ea 18 01 c9 	orh	r8,0x1c9
80002090:	10 3c       	cp.w	r12,r8
80002092:	e0 8b 00 0a 	brhi	800020a6 <flashcdw_set_flash_waitstate_and_readmode+0x2e>
			// Set a wait-state, disable the high-speed read mode.
			flashcdw_set_wait_state(1);
80002096:	30 1c       	mov	r12,1
80002098:	f0 1f 00 0c 	mcall	800020c8 <flashcdw_set_flash_waitstate_and_readmode+0x50>
			flashcdw_issue_command(AVR32_FLASHCDW_FCMD_CMD_HSDIS, -1);
8000209c:	3f fb       	mov	r11,-1
8000209e:	31 1c       	mov	r12,17
800020a0:	f0 1f 00 0b 	mcall	800020cc <flashcdw_set_flash_waitstate_and_readmode+0x54>
800020a4:	d8 02       	popm	pc
		} else {
			// Set a wait-state, enable the high-speed read mode.
			flashcdw_set_wait_state(1);
800020a6:	30 1c       	mov	r12,1
800020a8:	f0 1f 00 08 	mcall	800020c8 <flashcdw_set_flash_waitstate_and_readmode+0x50>
			flashcdw_issue_command(AVR32_FLASHCDW_FCMD_CMD_HSEN, -1);
800020ac:	3f fb       	mov	r11,-1
800020ae:	31 0c       	mov	r12,16
800020b0:	f0 1f 00 07 	mcall	800020cc <flashcdw_set_flash_waitstate_and_readmode+0x54>
800020b4:	d8 02       	popm	pc
		}
	} else { // <= 15MHz
		// No wait-state, disable the high-speed read mode
		flashcdw_set_wait_state(0);
800020b6:	30 0c       	mov	r12,0
800020b8:	f0 1f 00 04 	mcall	800020c8 <flashcdw_set_flash_waitstate_and_readmode+0x50>
		flashcdw_issue_command(AVR32_FLASHCDW_FCMD_CMD_HSDIS, -1);
800020bc:	3f fb       	mov	r11,-1
800020be:	31 1c       	mov	r12,17
800020c0:	f0 1f 00 03 	mcall	800020cc <flashcdw_set_flash_waitstate_and_readmode+0x54>
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	20 04       	sub	r4,0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	20 30       	sub	r0,3

800020d0 <spi_write_FPGA>:
		spi_addr = addr;// | 0x000B0000;
	} else {
		spi_data = data;// | 0x00070000;
		spi_addr = addr;// | 0x000B0000;
	}
	*(volatile uint32_t*)0xFFFF400C = spi_addr;	//send data to TX reg
800020d0:	fe 78 40 0c 	mov	r8,-49140
800020d4:	91 0b       	st.w	r8[0x0],r11
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
800020d6:	fe 78 40 10 	mov	r8,-49136
800020da:	70 09       	ld.w	r9,r8[0x0]
800020dc:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800020e0:	cf d0       	breq	800020da <spi_write_FPGA+0xa>
	rx_data = *((volatile uint32_t*)(0xFFFF4008));
800020e2:	fe 78 40 08 	mov	r8,-49144
800020e6:	70 08       	ld.w	r8,r8[0x0]
	
	*(volatile uint32_t*)0xFFFF400C = spi_data;	//send data to TX reg
800020e8:	fe 78 40 0c 	mov	r8,-49140
800020ec:	91 0a       	st.w	r8[0x0],r10
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
800020ee:	fe 78 40 10 	mov	r8,-49136
800020f2:	70 09       	ld.w	r9,r8[0x0]
800020f4:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800020f8:	cf d0       	breq	800020f2 <spi_write_FPGA+0x22>
	rx_data = *((volatile uint32_t*)(0xFFFF4008));
800020fa:	fe 78 40 08 	mov	r8,-49144
800020fe:	70 08       	ld.w	r8,r8[0x0]
	//while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_TXEMPTY_MASK) != AVR32_SPI_SR_TXEMPTY_MASK ); //wait for tx buffer to empty
}
80002100:	5e fc       	retal	r12
80002102:	d7 03       	nop

80002104 <send_binary_to_terminal>:
	}
	send_binary_to_terminal(*current_val);
	spi_write_FPGA(0,0x81,*current_val);
}

void send_binary_to_terminal(unsigned int data){
80002104:	eb cd 40 f8 	pushm	r3-r7,lr
80002108:	18 96       	mov	r6,r12
8000210a:	30 77       	mov	r7,7
	for(i = 7; i >= 0; i--){
		int bit = (data >> i) & 1;
		if (bit){
			usart_putchar((uint32_t*)0xFFFF3C00, 0x31);		//"1"
		} else {
			usart_putchar((uint32_t*)0xFFFF3C00, 0x30);		//"0"
8000210c:	33 04       	mov	r4,48
8000210e:	fe 75 3c 00 	mov	r5,-50176
void send_binary_to_terminal(unsigned int data){
	int i;
	for(i = 7; i >= 0; i--){
		int bit = (data >> i) & 1;
		if (bit){
			usart_putchar((uint32_t*)0xFFFF3C00, 0x31);		//"1"
80002112:	33 13       	mov	r3,49

void send_binary_to_terminal(unsigned int data){
	int i;
	for(i = 7; i >= 0; i--){
		int bit = (data >> i) & 1;
		if (bit){
80002114:	ec 07 0a 48 	lsr	r8,r6,r7
80002118:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000211c:	c0 60       	breq	80002128 <send_binary_to_terminal+0x24>
			usart_putchar((uint32_t*)0xFFFF3C00, 0x31);		//"1"
8000211e:	06 9b       	mov	r11,r3
80002120:	0a 9c       	mov	r12,r5
80002122:	f0 1f 00 09 	mcall	80002144 <send_binary_to_terminal+0x40>
80002126:	c0 58       	rjmp	80002130 <send_binary_to_terminal+0x2c>
		} else {
			usart_putchar((uint32_t*)0xFFFF3C00, 0x30);		//"0"
80002128:	08 9b       	mov	r11,r4
8000212a:	0a 9c       	mov	r12,r5
8000212c:	f0 1f 00 06 	mcall	80002144 <send_binary_to_terminal+0x40>
	spi_write_FPGA(0,0x81,*current_val);
}

void send_binary_to_terminal(unsigned int data){
	int i;
	for(i = 7; i >= 0; i--){
80002130:	20 17       	sub	r7,1
80002132:	5b f7       	cp.w	r7,-1
80002134:	cf 01       	brne	80002114 <send_binary_to_terminal+0x10>
			usart_putchar((uint32_t*)0xFFFF3C00, 0x31);		//"1"
		} else {
			usart_putchar((uint32_t*)0xFFFF3C00, 0x30);		//"0"
		}
	}
	usart_putchar((uint32_t*)0xFFFF3C00, 0x20);				//space
80002136:	32 0b       	mov	r11,32
80002138:	fe 7c 3c 00 	mov	r12,-50176
8000213c:	f0 1f 00 02 	mcall	80002144 <send_binary_to_terminal+0x40>
}
80002140:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	29 00       	sub	r0,-112

80002148 <configure_fpga>:
	}
	usart_putchar((uint32_t*)0xFFFF3C00, 0x0D);
	usart_putchar((uint32_t*)0xFFFF3C00, 0x0A);
}

int configure_fpga(unsigned int file_length){
80002148:	eb cd 40 fe 	pushm	r1-r7,lr
8000214c:	18 92       	mov	r2,r12
	int delay_len = 1;
	
	uint32_t config_file_start_addr = 4;
	
	// Configuration Reset
	gpio_clr_gpio_pin(AVR32_PIN_PA11);											//de-assert program_b to reset device
8000214e:	30 bc       	mov	r12,11
80002150:	f0 1f 00 28 	mcall	800021f0 <configure_fpga+0xa8>
	//gpio_tgl_gpio_pin(AVR32_PIN_PA20);											//used as a delay

	gpio_set_gpio_pin(AVR32_PIN_PA11);											//assert program_b to start configuration process
80002154:	30 bc       	mov	r12,11
80002156:	f0 1f 00 28 	mcall	800021f4 <configure_fpga+0xac>
	
	
	// Wait for Device Initialization
	while(gpio_get_pin_value(AVR32_PIN_PA22) == 0);							// wait until init_b is asserted and then send bit stream
8000215a:	31 67       	mov	r7,22
8000215c:	0e 9c       	mov	r12,r7
8000215e:	f0 1f 00 27 	mcall	800021f8 <configure_fpga+0xb0>
80002162:	cf d0       	breq	8000215c <configure_fpga+0x14>

	// Configuration (Bitstream) Load
	int addr, data8;
	gpio_clr_gpio_pin(AVR32_PIN_PB05);											//de-assert CCLK
80002164:	32 5c       	mov	r12,37
80002166:	f0 1f 00 23 	mcall	800021f0 <configure_fpga+0xa8>
	for (i = 0; i < file_length; i++) {
8000216a:	58 02       	cp.w	r2,0
8000216c:	c2 50       	breq	800021b6 <configure_fpga+0x6e>
8000216e:	30 0c       	mov	r12,0
80002170:	18 93       	mov	r3,r12
		//usart_putchar((uint32_t*)0xFFFF3C00, 'f');
		addr = config_file_start_addr + i;
		data8 = spi_read_flash(addr);											//read next byte, (clock is low, reading acts as a delay)
80002172:	30 71       	mov	r1,7
			uint32_t bitval = ((data8 >> j) & 1);
			if (bitval){
				gpio_set_gpio_pin(AVR32_PIN_PA05);								//if bit is 1 set DIN to 1
				//usart_putchar((uint32_t*)0xFFFF3C00, '1');
			} else {
				gpio_clr_gpio_pin(AVR32_PIN_PA05);								//if bit is 0 set DIN to 0
80002174:	30 54       	mov	r4,5
				//usart_putchar((uint32_t*)0xFFFF3C00, '0');
			}
			gpio_set_gpio_pin(AVR32_PIN_PB05);									//assert CCLK
80002176:	32 56       	mov	r6,37
	int addr, data8;
	gpio_clr_gpio_pin(AVR32_PIN_PB05);											//de-assert CCLK
	for (i = 0; i < file_length; i++) {
		//usart_putchar((uint32_t*)0xFFFF3C00, 'f');
		addr = config_file_start_addr + i;
		data8 = spi_read_flash(addr);											//read next byte, (clock is low, reading acts as a delay)
80002178:	2f cc       	sub	r12,-4
8000217a:	f0 1f 00 21 	mcall	800021fc <configure_fpga+0xb4>
8000217e:	18 95       	mov	r5,r12
80002180:	02 97       	mov	r7,r1
		for (j = 7; j >= 0; --j){
			uint32_t bitval = ((data8 >> j) & 1);
			if (bitval){
80002182:	ea 07 08 48 	asr	r8,r5,r7
80002186:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000218a:	c0 50       	breq	80002194 <configure_fpga+0x4c>
				gpio_set_gpio_pin(AVR32_PIN_PA05);								//if bit is 1 set DIN to 1
8000218c:	08 9c       	mov	r12,r4
8000218e:	f0 1f 00 1a 	mcall	800021f4 <configure_fpga+0xac>
80002192:	c0 48       	rjmp	8000219a <configure_fpga+0x52>
				//usart_putchar((uint32_t*)0xFFFF3C00, '1');
			} else {
				gpio_clr_gpio_pin(AVR32_PIN_PA05);								//if bit is 0 set DIN to 0
80002194:	08 9c       	mov	r12,r4
80002196:	f0 1f 00 17 	mcall	800021f0 <configure_fpga+0xa8>
				//usart_putchar((uint32_t*)0xFFFF3C00, '0');
			}
			gpio_set_gpio_pin(AVR32_PIN_PB05);									//assert CCLK
8000219a:	0c 9c       	mov	r12,r6
8000219c:	f0 1f 00 16 	mcall	800021f4 <configure_fpga+0xac>
			gpio_clr_gpio_pin(AVR32_PIN_PB05);									//de-assert CCLK
800021a0:	0c 9c       	mov	r12,r6
800021a2:	f0 1f 00 14 	mcall	800021f0 <configure_fpga+0xa8>
	gpio_clr_gpio_pin(AVR32_PIN_PB05);											//de-assert CCLK
	for (i = 0; i < file_length; i++) {
		//usart_putchar((uint32_t*)0xFFFF3C00, 'f');
		addr = config_file_start_addr + i;
		data8 = spi_read_flash(addr);											//read next byte, (clock is low, reading acts as a delay)
		for (j = 7; j >= 0; --j){
800021a6:	20 17       	sub	r7,1
800021a8:	5b f7       	cp.w	r7,-1
800021aa:	ce c1       	brne	80002182 <configure_fpga+0x3a>
	while(gpio_get_pin_value(AVR32_PIN_PA22) == 0);							// wait until init_b is asserted and then send bit stream

	// Configuration (Bitstream) Load
	int addr, data8;
	gpio_clr_gpio_pin(AVR32_PIN_PB05);											//de-assert CCLK
	for (i = 0; i < file_length; i++) {
800021ac:	2f f3       	sub	r3,-1
800021ae:	06 9c       	mov	r12,r3
800021b0:	06 32       	cp.w	r2,r3
800021b2:	fe 9b ff e3 	brhi	80002178 <configure_fpga+0x30>
			gpio_clr_gpio_pin(AVR32_PIN_PB05);									//de-assert CCLK
		}
	}
	
	// Check INIT_B
	if (gpio_get_pin_value(AVR32_PIN_PA22) == 0) {
800021b6:	31 6c       	mov	r12,22
800021b8:	f0 1f 00 10 	mcall	800021f8 <configure_fpga+0xb0>
800021bc:	c1 11       	brne	800021de <configure_fpga+0x96>
		usart_write_line((uint32_t*)0xFFFF3C00, "ERROR CONFIG 1!\r\n");
800021be:	49 1b       	lddpc	r11,80002200 <configure_fpga+0xb8>
800021c0:	fe 7c 3c 00 	mov	r12,-50176
800021c4:	f0 1f 00 10 	mcall	80002204 <configure_fpga+0xbc>
800021c8:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
		return 1;
	}
	// Wait for DONE to assert
	int timeout = 0xFF;
	while(gpio_get_pin_value(AVR32_PIN_PB10) == 0){
		timeout--;
800021cc:	20 17       	sub	r7,1
		if (timeout == 0){
800021ce:	c0 b1       	brne	800021e4 <configure_fpga+0x9c>
			usart_write_line((uint32_t*)0xFFFF3C00, "ERROR CONFIG 2!\r\n");
800021d0:	48 eb       	lddpc	r11,80002208 <configure_fpga+0xc0>
800021d2:	fe 7c 3c 00 	mov	r12,-50176
800021d6:	f0 1f 00 0c 	mcall	80002204 <configure_fpga+0xbc>
800021da:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
			break;
800021de:	e0 67 00 ff 	mov	r7,255
		usart_write_line((uint32_t*)0xFFFF3C00, "ERROR CONFIG 1!\r\n");
		return 1;
	}
	// Wait for DONE to assert
	int timeout = 0xFF;
	while(gpio_get_pin_value(AVR32_PIN_PB10) == 0){
800021e2:	32 a6       	mov	r6,42
800021e4:	0c 9c       	mov	r12,r6
800021e6:	f0 1f 00 05 	mcall	800021f8 <configure_fpga+0xb0>
800021ea:	cf 10       	breq	800021cc <configure_fpga+0x84>
800021ec:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	23 b8       	sub	r8,59
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	23 9c       	sub	r12,57
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	23 86       	sub	r6,56
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	28 26       	sub	r6,-126
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	32 00       	mov	r0,32
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	29 7c       	sub	r12,-105
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	32 14       	mov	r4,33

8000220c <gpio_enable_module_pin>:
}


int gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
8000220c:	f8 08 16 05 	lsr	r8,r12,0x5
80002210:	a9 78       	lsl	r8,0x9
80002212:	e0 28 d4 00 	sub	r8,54272

  // Enable the correct function.
  switch (function)
80002216:	58 7b       	cp.w	r11,7
80002218:	e0 8b 00 05 	brhi	80002222 <gpio_enable_module_pin+0x16>
8000221c:	4a 09       	lddpc	r9,8000229c <gpio_enable_module_pin+0x90>
8000221e:	f2 0b 03 2f 	ld.w	pc,r9[r11<<0x2]
80002222:	5e ff       	retal	1
  {
  case 0: // A function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
80002224:	30 19       	mov	r9,1
80002226:	f2 0c 09 49 	lsl	r9,r9,r12
8000222a:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
8000222c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
8000222e:	91 e9       	st.w	r8[0x38],r9
#endif
    break;
80002230:	c3 18       	rjmp	80002292 <gpio_enable_module_pin+0x86>

  case 1: // B function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
80002232:	30 19       	mov	r9,1
80002234:	f2 0c 09 49 	lsl	r9,r9,r12
80002238:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
8000223a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
8000223c:	91 e9       	st.w	r8[0x38],r9
#endif
    break;
8000223e:	c2 a8       	rjmp	80002292 <gpio_enable_module_pin+0x86>

  case 2: // C function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
80002240:	30 19       	mov	r9,1
80002242:	f2 0c 09 49 	lsl	r9,r9,r12
80002246:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
80002248:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
8000224a:	91 e9       	st.w	r8[0x38],r9
#endif
    break;
8000224c:	c2 38       	rjmp	80002292 <gpio_enable_module_pin+0x86>

  case 3: // D function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
8000224e:	30 19       	mov	r9,1
80002250:	f2 0c 09 49 	lsl	r9,r9,r12
80002254:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
80002256:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
80002258:	91 e9       	st.w	r8[0x38],r9
#endif
    break;
8000225a:	c1 c8       	rjmp	80002292 <gpio_enable_module_pin+0x86>

#if (AVR32_GPIO_H_VERSION >= 210)
  case 4: // E function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
8000225c:	30 19       	mov	r9,1
8000225e:	f2 0c 09 49 	lsl	r9,r9,r12
80002262:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
80002264:	91 a9       	st.w	r8[0x28],r9
    gpio_port->pmr2s = 1 << (pin & 0x1F);
80002266:	91 d9       	st.w	r8[0x34],r9
    break;
80002268:	c1 58       	rjmp	80002292 <gpio_enable_module_pin+0x86>

  case 5: // F function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
8000226a:	30 19       	mov	r9,1
8000226c:	f2 0c 09 49 	lsl	r9,r9,r12
80002270:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
80002272:	91 a9       	st.w	r8[0x28],r9
    gpio_port->pmr2s = 1 << (pin & 0x1F);
80002274:	91 d9       	st.w	r8[0x34],r9
    break;
80002276:	c0 e8       	rjmp	80002292 <gpio_enable_module_pin+0x86>

  case 6: // G function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
80002278:	30 19       	mov	r9,1
8000227a:	f2 0c 09 49 	lsl	r9,r9,r12
8000227e:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
80002280:	91 99       	st.w	r8[0x24],r9
    gpio_port->pmr2s = 1 << (pin & 0x1F);
80002282:	91 d9       	st.w	r8[0x34],r9
    break;
80002284:	c0 78       	rjmp	80002292 <gpio_enable_module_pin+0x86>

  case 7: // H function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
80002286:	30 19       	mov	r9,1
80002288:	f2 0c 09 49 	lsl	r9,r9,r12
8000228c:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
8000228e:	91 99       	st.w	r8[0x24],r9
    gpio_port->pmr2s = 1 << (pin & 0x1F);
80002290:	91 d9       	st.w	r8[0x34],r9
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
80002292:	30 19       	mov	r9,1
80002294:	f2 0c 09 4c 	lsl	r12,r9,r12
80002298:	91 2c       	st.w	r8[0x8],r12
8000229a:	5e fd       	retal	0
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	32 38       	mov	r8,35

800022a0 <gpio_enable_gpio_pin>:
}


void gpio_enable_gpio_pin(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800022a0:	f8 08 16 05 	lsr	r8,r12,0x5
800022a4:	a9 78       	lsl	r8,0x9
800022a6:	e0 28 d4 00 	sub	r8,54272
  gpio_port->oderc = 1 << (pin & 0x1F);
800022aa:	30 19       	mov	r9,1
800022ac:	f2 0c 09 4c 	lsl	r12,r9,r12
800022b0:	f1 4c 00 48 	st.w	r8[72],r12
  gpio_port->gpers = 1 << (pin & 0x1F);
800022b4:	91 1c       	st.w	r8[0x4],r12
}
800022b6:	5e fc       	retal	r12

800022b8 <gpio_enable_pin_pull_up>:
#endif


void gpio_enable_pin_pull_up(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800022b8:	f8 08 16 05 	lsr	r8,r12,0x5
800022bc:	a9 78       	lsl	r8,0x9
800022be:	e0 28 d4 00 	sub	r8,54272
  gpio_port->puers = 1 << (pin & 0x1F);
800022c2:	30 19       	mov	r9,1
800022c4:	f2 0c 09 4c 	lsl	r12,r9,r12
800022c8:	f1 4c 00 74 	st.w	r8[116],r12
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_212_H_INCLUDED)
  gpio_port->pderc = 1 << (pin & 0x1F);
#endif
}
800022cc:	5e fc       	retal	r12

800022ce <gpio_configure_pin>:

#endif

void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800022ce:	f8 08 16 05 	lsr	r8,r12,0x5
800022d2:	a9 78       	lsl	r8,0x9
800022d4:	e0 28 d4 00 	sub	r8,54272
    if (flags & GPIO_PULL_DOWN)
            gpio_port->pders = 1 << (pin & 0x1F);
    else
            gpio_port->pderc = 1 << (pin & 0x1F);
#endif
    if (flags & GPIO_PULL_UP)
800022d8:	16 99       	mov	r9,r11
800022da:	e2 19 00 04 	andl	r9,0x4,COH
800022de:	c0 70       	breq	800022ec <gpio_configure_pin+0x1e>
            gpio_port->puers = 1 << (pin & 0x1F);
800022e0:	30 19       	mov	r9,1
800022e2:	f2 0c 09 49 	lsl	r9,r9,r12
800022e6:	f1 49 00 74 	st.w	r8[116],r9
800022ea:	c0 68       	rjmp	800022f6 <gpio_configure_pin+0x28>
    else
            gpio_port->puerc = 1 << (pin & 0x1F);
800022ec:	30 19       	mov	r9,1
800022ee:	f2 0c 09 49 	lsl	r9,r9,r12
800022f2:	f1 49 00 78 	st.w	r8[120],r9
            else
                    gpio_port->odcr1c = 1 << (pin & 0x1F);
#endif

    /* Select interrupt level for group */
    if (flags & GPIO_INTERRUPT) {
800022f6:	16 99       	mov	r9,r11
800022f8:	e2 19 00 80 	andl	r9,0x80,COH
800022fc:	c2 40       	breq	80002344 <gpio_configure_pin+0x76>
            if (flags & GPIO_BOTHEDGES)
800022fe:	16 99       	mov	r9,r11
80002300:	e2 19 01 80 	andl	r9,0x180,COH
80002304:	c0 90       	breq	80002316 <gpio_configure_pin+0x48>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
80002306:	30 19       	mov	r9,1
80002308:	f2 0c 09 49 	lsl	r9,r9,r12
8000230c:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
80002310:	f1 49 00 b8 	st.w	r8[184],r9
80002314:	c1 88       	rjmp	80002344 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_RISING)
80002316:	16 99       	mov	r9,r11
80002318:	e2 19 02 80 	andl	r9,0x280,COH
8000231c:	c0 90       	breq	8000232e <gpio_configure_pin+0x60>
            {
                   gpio_port->imr0s = 1 << (pin & 0x1F);
8000231e:	30 19       	mov	r9,1
80002320:	f2 0c 09 49 	lsl	r9,r9,r12
80002324:	f1 49 00 a4 	st.w	r8[164],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
80002328:	f1 49 00 b8 	st.w	r8[184],r9
8000232c:	c0 c8       	rjmp	80002344 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_FALLING)
8000232e:	16 99       	mov	r9,r11
80002330:	e2 19 03 80 	andl	r9,0x380,COH
80002334:	c0 80       	breq	80002344 <gpio_configure_pin+0x76>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
80002336:	30 19       	mov	r9,1
80002338:	f2 0c 09 49 	lsl	r9,r9,r12
8000233c:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1s = 1 << (pin & 0x1F);
80002340:	f1 49 00 b4 	st.w	r8[180],r9
            }
    }

    /* Select direction and initial pin state */
    if (flags & GPIO_DIR_OUTPUT) {
80002344:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
80002348:	c1 50       	breq	80002372 <gpio_configure_pin+0xa4>
            if (flags & GPIO_INIT_HIGH)
8000234a:	e2 1b 00 02 	andl	r11,0x2,COH
8000234e:	c0 70       	breq	8000235c <gpio_configure_pin+0x8e>
                    gpio_port->ovrs = 1 << (pin & 0x1F);
80002350:	30 19       	mov	r9,1
80002352:	f2 0c 09 49 	lsl	r9,r9,r12
80002356:	f1 49 00 54 	st.w	r8[84],r9
8000235a:	c0 68       	rjmp	80002366 <gpio_configure_pin+0x98>
            else
                    gpio_port->ovrc = 1 << (pin & 0x1F);
8000235c:	30 19       	mov	r9,1
8000235e:	f2 0c 09 49 	lsl	r9,r9,r12
80002362:	f1 49 00 58 	st.w	r8[88],r9
            gpio_port->oders = 1 << (pin & 0x1F);
80002366:	30 19       	mov	r9,1
80002368:	f2 0c 09 49 	lsl	r9,r9,r12
8000236c:	f1 49 00 44 	st.w	r8[68],r9
80002370:	c0 68       	rjmp	8000237c <gpio_configure_pin+0xae>
    } else {
            gpio_port->oderc = 1 << (pin & 0x1F);
80002372:	30 19       	mov	r9,1
80002374:	f2 0c 09 49 	lsl	r9,r9,r12
80002378:	f1 49 00 48 	st.w	r8[72],r9
    }

    /* Enable GPIO */
    gpio_port->gpers = 1 << (pin & 0x1F);
8000237c:	30 19       	mov	r9,1
8000237e:	f2 0c 09 4c 	lsl	r12,r9,r12
80002382:	91 1c       	st.w	r8[0x4],r12
}
80002384:	5e fc       	retal	r12

80002386 <gpio_get_pin_value>:
    gpio_port->gpers = mask;
}

int gpio_get_pin_value(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002386:	f8 08 16 05 	lsr	r8,r12,0x5
8000238a:	a9 78       	lsl	r8,0x9
8000238c:	e0 28 d4 00 	sub	r8,54272
  return (gpio_port->pvr >> (pin & 0x1F)) & 1;
80002390:	71 88       	ld.w	r8,r8[0x60]
80002392:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80002396:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
8000239a:	5e fc       	retal	r12

8000239c <gpio_set_gpio_pin>:
}


void gpio_set_gpio_pin(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
8000239c:	f8 08 16 05 	lsr	r8,r12,0x5
800023a0:	a9 78       	lsl	r8,0x9
800023a2:	e0 28 d4 00 	sub	r8,54272
  gpio_port->ovrs  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 1.
800023a6:	30 19       	mov	r9,1
800023a8:	f2 0c 09 4c 	lsl	r12,r9,r12
800023ac:	f1 4c 00 54 	st.w	r8[84],r12
  gpio_port->oders = 1 << (pin & 0x1F); // The GPIO output driver is enabled for that pin.
800023b0:	f1 4c 00 44 	st.w	r8[68],r12
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
800023b4:	91 1c       	st.w	r8[0x4],r12
}
800023b6:	5e fc       	retal	r12

800023b8 <gpio_clr_gpio_pin>:
  gpio_port->ovrc  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 0.
}

void gpio_clr_gpio_pin(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800023b8:	f8 08 16 05 	lsr	r8,r12,0x5
800023bc:	a9 78       	lsl	r8,0x9
800023be:	e0 28 d4 00 	sub	r8,54272
  gpio_port->ovrc  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 0.
800023c2:	30 19       	mov	r9,1
800023c4:	f2 0c 09 4c 	lsl	r12,r9,r12
800023c8:	f1 4c 00 58 	st.w	r8[88],r12
  gpio_port->oders = 1 << (pin & 0x1F); // The GPIO output driver is enabled for that pin.
800023cc:	f1 4c 00 44 	st.w	r8[68],r12
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
800023d0:	91 1c       	st.w	r8[0x4],r12
}
800023d2:	5e fc       	retal	r12

800023d4 <i2c_set_speed>:

# include "i2cfun.h"

int i2c_set_speed (uint32_t speed,uint32_t pba_hz)
{
800023d4:	d4 01       	pushm	lr
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
800023d6:	f6 0c 0d 0a 	divu	r10,r11,r12
800023da:	f4 08 16 01 	lsr	r8,r10,0x1
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
800023de:	e0 48 00 ff 	cp.w	r8,255
800023e2:	e0 8b 00 04 	brhi	800023ea <i2c_set_speed+0x16>
800023e6:	30 09       	mov	r9,0
800023e8:	c1 88       	rjmp	80002418 <i2c_set_speed+0x44>
800023ea:	30 09       	mov	r9,0
800023ec:	30 7e       	mov	lr,7
800023ee:	30 0c       	mov	r12,0
		// increase clock divider
		cwgr_exp++;
800023f0:	2f f9       	sub	r9,-1
800023f2:	5c 59       	castu.b	r9
		// divide f_prescaled value
		f_prescaled /= 2;
800023f4:	a1 98       	lsr	r8,0x1
{
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
800023f6:	e0 48 00 ff 	cp.w	r8,255
800023fa:	5f bb       	srhi	r11
800023fc:	fc 09 18 00 	cp.b	r9,lr
80002400:	5f 8a       	srls	r10
80002402:	f7 ea 00 0a 	and	r10,r11,r10
80002406:	f8 0a 18 00 	cp.b	r10,r12
8000240a:	cf 31       	brne	800023f0 <i2c_set_speed+0x1c>
		// increase clock divider
		cwgr_exp++;
		// divide f_prescaled value
		f_prescaled /= 2;
	}
	if (cwgr_exp > 0x7) {
8000240c:	30 7a       	mov	r10,7
8000240e:	f4 09 18 00 	cp.b	r9,r10
80002412:	e0 88 00 03 	brls	80002418 <i2c_set_speed+0x44>
80002416:	d8 0a       	popm	pc,r12=0
		return 0;
	}
	// set clock waveform generator register
	*(volatile uint32_t *)0xFFFF4404 = ((f_prescaled/2))
	| ((f_prescaled - f_prescaled/2) << 8)
80002418:	f0 0a 16 01 	lsr	r10,r8,0x1
	}
	if (cwgr_exp > 0x7) {
		return 0;
	}
	// set clock waveform generator register
	*(volatile uint32_t *)0xFFFF4404 = ((f_prescaled/2))
8000241c:	f5 e8 11 0b 	or	r11,r10,r8<<0x10
80002420:	14 18       	sub	r8,r10
80002422:	f7 e8 10 88 	or	r8,r11,r8<<0x8
80002426:	f1 e9 11 c9 	or	r9,r8,r9<<0x1c
8000242a:	fe 78 44 04 	mov	r8,-48124
8000242e:	91 09       	st.w	r8[0x0],r9
80002430:	da 0a       	popm	pc,r12=1
80002432:	d7 03       	nop

80002434 <i2c_init>:
	| (0     << 24)
	| (f_prescaled << 16);
	return 1;
}

void i2c_init(){
80002434:	d4 01       	pushm	lr
	i2c_set_speed(100000,17200000);
80002436:	e0 6b 73 80 	mov	r11,29568
8000243a:	ea 1b 01 06 	orh	r11,0x106
8000243e:	e0 7c 86 a0 	mov	r12,100000
80002442:	f0 1f 00 07 	mcall	8000245c <i2c_init+0x28>
	*(volatile uint32_t *)0xFFFF4424 = 0x0000ffff;					//disable interupts
80002446:	e0 69 ff ff 	mov	r9,65535
8000244a:	fe 78 44 24 	mov	r8,-48092
8000244e:	91 09       	st.w	r8[0x0],r9
	*(volatile uint32_t *)0xFFFF4400 = 0x00000021;					//enable master interface
80002450:	32 19       	mov	r9,33
80002452:	fe 78 44 00 	mov	r8,-48128
80002456:	91 09       	st.w	r8[0x0],r9
}
80002458:	d8 02       	popm	pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	23 d4       	sub	r4,61

80002460 <i2c_write>:

int i2c_write(int addr,char * data,int numbytes){
80002460:	d4 01       	pushm	lr
	int i;
	*(volatile uint32_t *)0xFFFF440C = 0x0000E000 | ( (0x7F & addr) << 1 ) | ((0xFF & numbytes)<<16);		//load command reg
80002462:	f8 09 15 01 	lsl	r9,r12,0x1
80002466:	f3 d9 c0 08 	bfextu	r9,r9,0x0,0x8
8000246a:	e8 19 e0 00 	orl	r9,0xe000
8000246e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80002472:	f3 e8 11 09 	or	r9,r9,r8<<0x10
80002476:	fe 78 44 0c 	mov	r8,-48116
8000247a:	91 09       	st.w	r8[0x0],r9
	for (i = 0; i < numbytes; i++){
8000247c:	58 0a       	cp.w	r10,0
8000247e:	e0 89 00 0d 	brgt	80002498 <i2c_write+0x38>
80002482:	c1 c8       	rjmp	800024ba <i2c_write+0x5a>
		while(!(*((volatile uint32_t*)(0xFFFF441C)) & 2)){									//wait for tx reg to empty
			if (*((volatile uint32_t*)(0xFFFF441C)) & 0x00000300){							//if no ack exit
80002484:	70 09       	ld.w	r9,r8[0x0]
80002486:	e2 19 03 00 	andl	r9,0x300,COH
8000248a:	c0 c0       	breq	800024a2 <i2c_write+0x42>
				*((volatile uint32_t*)(0xFFFF442C)) = 0x00000300;
8000248c:	e0 69 03 00 	mov	r9,768
80002490:	fe 78 44 2c 	mov	r8,-48084
80002494:	91 09       	st.w	r8[0x0],r9
80002496:	d8 0a       	popm	pc,r12=0
				return 0;
80002498:	30 0c       	mov	r12,0

int i2c_write(int addr,char * data,int numbytes){
	int i;
	*(volatile uint32_t *)0xFFFF440C = 0x0000E000 | ( (0x7F & addr) << 1 ) | ((0xFF & numbytes)<<16);		//load command reg
	for (i = 0; i < numbytes; i++){
		while(!(*((volatile uint32_t*)(0xFFFF441C)) & 2)){									//wait for tx reg to empty
8000249a:	fe 78 44 1c 	mov	r8,-48100
			if (*((volatile uint32_t*)(0xFFFF441C)) & 0x00000300){							//if no ack exit
				*((volatile uint32_t*)(0xFFFF442C)) = 0x00000300;
				return 0;
			}
		}
		*(volatile uint32_t *)0xFFFF4418 = *(volatile char *)data++;											//load data reg
8000249e:	fe 7e 44 18 	mov	lr,-48104

int i2c_write(int addr,char * data,int numbytes){
	int i;
	*(volatile uint32_t *)0xFFFF440C = 0x0000E000 | ( (0x7F & addr) << 1 ) | ((0xFF & numbytes)<<16);		//load command reg
	for (i = 0; i < numbytes; i++){
		while(!(*((volatile uint32_t*)(0xFFFF441C)) & 2)){									//wait for tx reg to empty
800024a2:	70 09       	ld.w	r9,r8[0x0]
800024a4:	e2 19 00 02 	andl	r9,0x2,COH
800024a8:	ce e0       	breq	80002484 <i2c_write+0x24>
800024aa:	f6 0c 00 09 	add	r9,r11,r12
			if (*((volatile uint32_t*)(0xFFFF441C)) & 0x00000300){							//if no ack exit
				*((volatile uint32_t*)(0xFFFF442C)) = 0x00000300;
				return 0;
			}
		}
		*(volatile uint32_t *)0xFFFF4418 = *(volatile char *)data++;											//load data reg
800024ae:	13 89       	ld.ub	r9,r9[0x0]
800024b0:	9d 09       	st.w	lr[0x0],r9
}

int i2c_write(int addr,char * data,int numbytes){
	int i;
	*(volatile uint32_t *)0xFFFF440C = 0x0000E000 | ( (0x7F & addr) << 1 ) | ((0xFF & numbytes)<<16);		//load command reg
	for (i = 0; i < numbytes; i++){
800024b2:	2f fc       	sub	r12,-1
800024b4:	18 3a       	cp.w	r10,r12
800024b6:	fe 99 ff f6 	brgt	800024a2 <i2c_write+0x42>
800024ba:	da 0a       	popm	pc,r12=1

800024bc <i2c_read>:
		*(volatile uint32_t *)0xFFFF4418 = *(volatile char *)data++;											//load data reg
	}
	return 1;
}

int i2c_read(int addr,int numbytes){
800024bc:	eb cd 40 e0 	pushm	r5-r7,lr
800024c0:	1a 97       	mov	r7,sp
		}
		data[i] = *(volatile uint32_t *)0xFFFF4414;
		temp = temp<<8 | data[i];
	}
	return temp;
}
800024c2:	1a 98       	mov	r8,sp
	}
	return 1;
}

int i2c_read(int addr,int numbytes){
	char data[numbytes];
800024c4:	f6 c9 ff fa 	sub	r9,r11,-6
800024c8:	e0 19 ff fc 	andl	r9,0xfffc
800024cc:	12 1d       	sub	sp,r9
800024ce:	1a 99       	mov	r9,sp
	int i;
	int temp = 0;
	*(volatile uint32_t *)0xFFFF440C = 0x0000E000 | ( (0x7F & addr) << 1 ) | ((0xFF & numbytes)<<16) | 1;
800024d0:	a1 7c       	lsl	r12,0x1
800024d2:	f9 dc c0 08 	bfextu	r12,r12,0x0,0x8
800024d6:	e8 1c e0 01 	orl	r12,0xe001
800024da:	f5 db c0 08 	bfextu	r10,r11,0x0,0x8
800024de:	f9 ea 11 0c 	or	r12,r12,r10<<0x10
800024e2:	fe 7a 44 0c 	mov	r10,-48116
800024e6:	95 0c       	st.w	r10[0x0],r12
	for (i = 0; i < numbytes; i++){
800024e8:	58 0b       	cp.w	r11,0
800024ea:	e0 89 00 0f 	brgt	80002508 <i2c_read+0x4c>
800024ee:	30 0c       	mov	r12,0
800024f0:	c2 08       	rjmp	80002530 <i2c_read+0x74>
		while(!(*((volatile uint32_t*)(0xFFFF441C)) & 1)){
			if (*((volatile uint32_t*)(0xFFFF441C)) & 0x00000300){
800024f2:	74 0e       	ld.w	lr,r10[0x0]
800024f4:	e2 1e 03 00 	andl	lr,0x300,COH
800024f8:	c0 e0       	breq	80002514 <i2c_read+0x58>
				*((volatile uint32_t*)(0xFFFF442C)) = 0x00000300;
800024fa:	e0 6a 03 00 	mov	r10,768
800024fe:	fe 79 44 2c 	mov	r9,-48084
80002502:	93 0a       	st.w	r9[0x0],r10
80002504:	30 0c       	mov	r12,0
80002506:	c1 58       	rjmp	80002530 <i2c_read+0x74>
80002508:	30 0c       	mov	r12,0
8000250a:	18 95       	mov	r5,r12
	char data[numbytes];
	int i;
	int temp = 0;
	*(volatile uint32_t *)0xFFFF440C = 0x0000E000 | ( (0x7F & addr) << 1 ) | ((0xFF & numbytes)<<16) | 1;
	for (i = 0; i < numbytes; i++){
		while(!(*((volatile uint32_t*)(0xFFFF441C)) & 1)){
8000250c:	fe 7a 44 1c 	mov	r10,-48100
			if (*((volatile uint32_t*)(0xFFFF441C)) & 0x00000300){
				*((volatile uint32_t*)(0xFFFF442C)) = 0x00000300;
				return 0;
			}
		}
		data[i] = *(volatile uint32_t *)0xFFFF4414;
80002510:	fe 76 44 14 	mov	r6,-48108
	char data[numbytes];
	int i;
	int temp = 0;
	*(volatile uint32_t *)0xFFFF440C = 0x0000E000 | ( (0x7F & addr) << 1 ) | ((0xFF & numbytes)<<16) | 1;
	for (i = 0; i < numbytes; i++){
		while(!(*((volatile uint32_t*)(0xFFFF441C)) & 1)){
80002514:	74 0e       	ld.w	lr,r10[0x0]
80002516:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
8000251a:	ce c0       	breq	800024f2 <i2c_read+0x36>
			if (*((volatile uint32_t*)(0xFFFF441C)) & 0x00000300){
				*((volatile uint32_t*)(0xFFFF442C)) = 0x00000300;
				return 0;
			}
		}
		data[i] = *(volatile uint32_t *)0xFFFF4414;
8000251c:	6c 0e       	ld.w	lr,r6[0x0]
8000251e:	5c 5e       	castu.b	lr
80002520:	f2 05 0b 0e 	st.b	r9[r5],lr
		temp = temp<<8 | data[i];
80002524:	fd ec 10 8c 	or	r12,lr,r12<<0x8
int i2c_read(int addr,int numbytes){
	char data[numbytes];
	int i;
	int temp = 0;
	*(volatile uint32_t *)0xFFFF440C = 0x0000E000 | ( (0x7F & addr) << 1 ) | ((0xFF & numbytes)<<16) | 1;
	for (i = 0; i < numbytes; i++){
80002528:	2f f5       	sub	r5,-1
8000252a:	0a 3b       	cp.w	r11,r5
8000252c:	fe 99 ff f4 	brgt	80002514 <i2c_read+0x58>
		}
		data[i] = *(volatile uint32_t *)0xFFFF4414;
		temp = temp<<8 | data[i];
	}
	return temp;
}
80002530:	10 9d       	mov	sp,r8
80002532:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002536:	d7 03       	nop

80002538 <getLidar>:

int getLidar(){
80002538:	d4 01       	pushm	lr
8000253a:	20 2d       	sub	sp,8
	int val = -1;
	char data1[2] = {0x00,0x04};
8000253c:	30 08       	mov	r8,0
8000253e:	ba c8       	st.b	sp[0x4],r8
80002540:	30 48       	mov	r8,4
80002542:	ba d8       	st.b	sp[0x5],r8
	char data2 = 0x8f;
80002544:	38 f8       	mov	r8,-113
80002546:	ba b8       	st.b	sp[0x3],r8
	i2c_write(0x62,&data1,2);
80002548:	30 2a       	mov	r10,2
8000254a:	fa cb ff fc 	sub	r11,sp,-4
8000254e:	36 2c       	mov	r12,98
80002550:	f0 1f 00 07 	mcall	8000256c <getLidar+0x34>
	val = val*2;
	i2c_write(0x62,&data2,1);
80002554:	30 1a       	mov	r10,1
80002556:	fa cb ff fd 	sub	r11,sp,-3
8000255a:	36 2c       	mov	r12,98
8000255c:	f0 1f 00 04 	mcall	8000256c <getLidar+0x34>
	val = val*2;
	val = i2c_read(0x62,2);
80002560:	30 2b       	mov	r11,2
80002562:	36 2c       	mov	r12,98
80002564:	f0 1f 00 03 	mcall	80002570 <getLidar+0x38>
	return val;
}
80002568:	2f ed       	sub	sp,-8
8000256a:	d8 02       	popm	pc
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	24 60       	sub	r0,70
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	24 bc       	sub	r12,75

80002574 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002574:	fe 78 10 00 	mov	r8,-61440
80002578:	e0 69 00 83 	mov	r9,131
8000257c:	f2 0c 01 0c 	sub	r12,r9,r12
80002580:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002584:	f2 ca ff c0 	sub	r10,r9,-64
80002588:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000258c:	58 08       	cp.w	r8,0
8000258e:	c0 21       	brne	80002592 <_get_interrupt_handler+0x1e>
80002590:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002592:	f0 08 12 00 	clz	r8,r8
80002596:	48 5a       	lddpc	r10,800025a8 <_get_interrupt_handler+0x34>
80002598:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000259c:	f0 08 11 1f 	rsub	r8,r8,31
800025a0:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800025a2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800025a6:	5e fc       	retal	r12
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	32 58       	mov	r8,37

800025ac <pm_set_clk_domain_div>:
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800025ac:	fe 78 14 00 	mov	r8,-60416
800025b0:	70 1a       	ld.w	r10,r8[0x4]
  if((divratio > PM_CPUSEL_DIVRATIO_MAX)||(divratio < 0))
    return -1;
#endif

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
800025b2:	10 99       	mov	r9,r8
800025b4:	f2 f8 00 d4 	ld.w	r8,r9[212]
800025b8:	e2 18 00 20 	andl	r8,0x20,COH
800025bc:	cf c0       	breq	800025b4 <pm_set_clk_domain_div+0x8>
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800025be:	14 98       	mov	r8,r10

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= 1;
800025c0:	30 19       	mov	r9,1
800025c2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_pm_cpusel.CPUSEL.cpusel = divratio;
800025c6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  AVR32_ENTER_CRITICAL_REGION( );
800025ca:	e1 b9 00 00 	mfsr	r9,0x0
800025ce:	d3 03       	ssrf	0x10
  // Unlock the write-protected ckSEL register
  PM_UNLOCK(AVR32_PM_CPUSEL + clock_domain*sizeof(avr32_pm_cpusel_t));
800025d0:	f8 cb ff ff 	sub	r11,r12,-1
800025d4:	a3 6b       	lsl	r11,0x2
800025d6:	ea 1b aa 00 	orh	r11,0xaa00
800025da:	fe 7a 14 00 	mov	r10,-60416
800025de:	f5 4b 00 58 	st.w	r10[88],r11
  // Update
  *(&(AVR32_PM.cpusel) + clock_domain)= u_avr32_pm_cpusel.cpusel;
800025e2:	a3 6c       	lsl	r12,0x2
800025e4:	e0 2c eb fc 	sub	r12,60412
800025e8:	99 08       	st.w	r12[0x0],r8
  AVR32_LEAVE_CRITICAL_REGION( );
800025ea:	12 98       	mov	r8,r9
800025ec:	e6 18 00 01 	andh	r8,0x1,COH
800025f0:	c0 21       	brne	800025f4 <pm_set_clk_domain_div+0x48>
800025f2:	d5 03       	csrf	0x10

  return PASS;
}
800025f4:	5e fd       	retal	0

800025f6 <pm_set_mclk_source>:
 ** Clock Functions
 **/

long pm_set_mclk_source(pm_clk_src_t src)
{
  AVR32_ENTER_CRITICAL_REGION( );
800025f6:	e1 b9 00 00 	mfsr	r9,0x0
800025fa:	d3 03       	ssrf	0x10
  // Unlock the write-protected MCCTRL register
  PM_UNLOCK(AVR32_PM_MCCTRL);
800025fc:	fe 78 14 00 	mov	r8,-60416
80002600:	fc 1a aa 00 	movh	r10,0xaa00
80002604:	f1 4a 00 58 	st.w	r8[88],r10
  AVR32_PM.mcctrl = src;
80002608:	91 0c       	st.w	r8[0x0],r12
  AVR32_LEAVE_CRITICAL_REGION( );
8000260a:	12 98       	mov	r8,r9
8000260c:	e6 18 00 01 	andh	r8,0x1,COH
80002610:	c0 21       	brne	80002614 <pm_set_mclk_source+0x1e>
80002612:	d5 03       	csrf	0x10

  return PASS;
}
80002614:	5e fd       	retal	0

80002616 <scif_stop_gclk>:
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;
80002616:	fe 78 18 00 	mov	r8,-59392
8000261a:	f8 c9 ff e4 	sub	r9,r12,-28
8000261e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80002622:	a1 ca       	cbr	r10,0x0
80002624:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002628:	e0 78 86 a0 	mov	r8,100000

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
8000262c:	fe 7a 18 00 	mov	r10,-59392
80002630:	12 9c       	mov	r12,r9
80002632:	c0 48       	rjmp	8000263a <scif_stop_gclk+0x24>
  {
    if(--timeout == 0)
80002634:	20 18       	sub	r8,1
80002636:	c0 21       	brne	8000263a <scif_stop_gclk+0x24>
80002638:	5e fe       	retal	-1

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
8000263a:	f4 0c 03 29 	ld.w	r9,r10[r12<<0x2]
8000263e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80002642:	cf 91       	brne	80002634 <scif_stop_gclk+0x1e>
80002644:	5e fd       	retal	0
80002646:	d7 03       	nop

80002648 <scif_gc_setup>:
  return PASS;
}


long int scif_gc_setup(unsigned int gclk, scif_gcctrl_oscsel_t clk_src, unsigned int diven, unsigned int divfactor)
{
80002648:	d4 21       	pushm	r4-r7,lr
8000264a:	18 97       	mov	r7,r12
8000264c:	16 95       	mov	r5,r11
8000264e:	14 96       	mov	r6,r10
  int restart_gc = false;


  // Change the division factor to conform to the equation: fgclk = fsrc/divfactor = fsrc/(2*(div+1))
  divfactor = (divfactor>>1) -1;
80002650:	a1 99       	lsr	r9,0x1
80002652:	f2 c4 00 01 	sub	r4,r9,1
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
80002656:	f8 c9 ff e4 	sub	r9,r12,-28
8000265a:	fe 78 18 00 	mov	r8,-59392
8000265e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80002662:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002666:	c0 50       	breq	80002670 <scif_gc_setup+0x28>
  {
    restart_gc = true;
    if(scif_stop_gclk(gclk) < 0)
80002668:	f0 1f 00 15 	mcall	800026bc <scif_gc_setup+0x74>
8000266c:	c1 14       	brge	8000268e <scif_gc_setup+0x46>
8000266e:	dc 2a       	popm	r4-r7,pc,r12=-1
      return -1;  // Could not stop the generic clock.
  }

  // Setup the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((divfactor << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
80002670:	a1 76       	lsl	r6,0x1
80002672:	e2 16 00 02 	andl	r6,0x2,COH
80002676:	a9 65       	lsl	r5,0x8
80002678:	e2 15 1f 00 	andl	r5,0x1f00,COH
8000267c:	0a 46       	or	r6,r5
8000267e:	ed e4 11 04 	or	r4,r6,r4<<0x10
80002682:	2e 47       	sub	r7,-28
80002684:	fe 78 18 00 	mov	r8,-59392
80002688:	f0 07 09 24 	st.w	r8[r7<<0x2],r4
8000268c:	d8 2a       	popm	r4-r7,pc,r12=0
8000268e:	ec 09 15 01 	lsl	r9,r6,0x1
80002692:	e2 19 00 02 	andl	r9,0x2,COH
80002696:	ea 08 15 08 	lsl	r8,r5,0x8
8000269a:	e2 18 1f 00 	andl	r8,0x1f00,COH
8000269e:	f3 e8 10 08 	or	r8,r9,r8
800026a2:	f1 e4 11 04 	or	r4,r8,r4<<0x10
800026a6:	fe 78 18 00 	mov	r8,-59392
800026aa:	2e 47       	sub	r7,-28
800026ac:	f0 07 09 24 	st.w	r8[r7<<0x2],r4
                            |((diven << AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&AVR32_SCIF_GCCTRL_DIVEN_MASK)
                            |((clk_src << AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&AVR32_SCIF_GCCTRL_OSCSEL_MASK);

  // Restart the gc if it previously was enabled.
  if(true == restart_gc)
    AVR32_SCIF.gcctrl[gclk] |= (AVR32_SCIF_GCCTRL_CEN_MASK);
800026b0:	f0 07 03 29 	ld.w	r9,r8[r7<<0x2]
800026b4:	a1 a9       	sbr	r9,0x0
800026b6:	f0 07 09 29 	st.w	r8[r7<<0x2],r9
800026ba:	d8 2a       	popm	r4-r7,pc,r12=0
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	26 16       	sub	r6,97

800026c0 <scif_gc_enable>:
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, do nothing.
  if(!(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK))
800026c0:	f8 c9 ff e4 	sub	r9,r12,-28
800026c4:	fe 78 18 00 	mov	r8,-59392
800026c8:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800026cc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800026d0:	c0 91       	brne	800026e2 <scif_gc_enable+0x22>
    AVR32_SCIF.gcctrl[gclk] |= (AVR32_SCIF_GCCTRL_CEN_MASK);
800026d2:	fe 78 18 00 	mov	r8,-59392
800026d6:	12 9c       	mov	r12,r9
800026d8:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800026dc:	a1 a9       	sbr	r9,0x0
800026de:	f0 0c 09 29 	st.w	r8[r12<<0x2],r9

  return PASS;
}
800026e2:	5e fd       	retal	0

800026e4 <scif_pclksr_statushigh_wait>:
 * \return Status.
 *   \retval 0   Status is high.
 *   \retval <0  SCIF_POLL_TIMEOUT Timeout expired before the status was high.
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
800026e4:	e0 78 86 a0 	mov	r8,100000
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
800026e8:	fe 7a 18 00 	mov	r10,-59392
800026ec:	c0 48       	rjmp	800026f4 <scif_pclksr_statushigh_wait+0x10>
  {
    if(--timeout == 0)
800026ee:	20 18       	sub	r8,1
800026f0:	c0 21       	brne	800026f4 <scif_pclksr_statushigh_wait+0x10>
800026f2:	5e fe       	retal	-1
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
800026f4:	74 59       	ld.w	r9,r10[0x14]
800026f6:	f9 e9 00 09 	and	r9,r12,r9
800026fa:	cf a0       	breq	800026ee <scif_pclksr_statushigh_wait+0xa>
800026fc:	5e fd       	retal	0
800026fe:	d7 03       	nop

80002700 <scif_dfll0_openloop_start>:
  SCIF_DFLL0_MODE_OPENLOOP = 0,
  SCIF_DFLL0_MODE_CLOSEDLOOP
} scif_dfll_mode_t;

long int scif_dfll0_openloop_start(const scif_dfll_openloop_conf_t *pdfllconfig)
{
80002700:	eb cd 40 c0 	pushm	r6-r7,lr
80002704:	18 96       	mov	r6,r12
  u_avr32_scif_dfll0conf_t  u_avr32_scif_dfll0conf = {AVR32_SCIF.dfll0conf};
80002706:	fe 78 18 00 	mov	r8,-59392
8000270a:	70 97       	ld.w	r7,r8[0x24]
  if((pdfllconfig->coarse >> AVR32_SCIF_DFLL0CONF_COARSE_SIZE))
    return -1;
#endif

  // Enable the DFLL0: DFLL0CONF.EN=1
  u_avr32_scif_dfll0conf.DFLL0CONF.en = ENABLE;
8000270c:	30 19       	mov	r9,1
8000270e:	ef d9 d0 01 	bfins	r7,r9,0x0,0x1
  AVR32_ENTER_CRITICAL_REGION( );
80002712:	e1 b9 00 00 	mfsr	r9,0x0
80002716:	d3 03       	ssrf	0x10
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
80002718:	32 4a       	mov	r10,36
8000271a:	ea 1a aa 00 	orh	r10,0xaa00
8000271e:	91 6a       	st.w	r8[0x18],r10
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
80002720:	91 97       	st.w	r8[0x24],r7
  AVR32_LEAVE_CRITICAL_REGION( );
80002722:	12 98       	mov	r8,r9
80002724:	e6 18 00 01 	andh	r8,0x1,COH
80002728:	c0 21       	brne	8000272c <scif_dfll0_openloop_start+0x2c>
8000272a:	d5 03       	csrf	0x10

  // Wait for PCLKSR.DFLL0RDY is high
  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_DFLL0RDY_MASK))
8000272c:	e0 6c 40 00 	mov	r12,16384
80002730:	f0 1f 00 1c 	mcall	800027a0 <scif_dfll0_openloop_start+0xa0>
80002734:	c3 21       	brne	80002798 <scif_dfll0_openloop_start+0x98>
    return -1;

  // Set the DFLL0 to operate in open mode: DFLL0CONF.MODE=0
  u_avr32_scif_dfll0conf.DFLL0CONF.mode = SCIF_DFLL0_MODE_OPENLOOP;
80002736:	30 08       	mov	r8,0
80002738:	ef d8 d0 21 	bfins	r7,r8,0x1,0x1
  AVR32_ENTER_CRITICAL_REGION( );
8000273c:	e1 b9 00 00 	mfsr	r9,0x0
80002740:	d3 03       	ssrf	0x10
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
80002742:	fe 78 18 00 	mov	r8,-59392
80002746:	32 4a       	mov	r10,36
80002748:	ea 1a aa 00 	orh	r10,0xaa00
8000274c:	91 6a       	st.w	r8[0x18],r10
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
8000274e:	91 97       	st.w	r8[0x24],r7
  AVR32_LEAVE_CRITICAL_REGION( );
80002750:	12 98       	mov	r8,r9
80002752:	e6 18 00 01 	andh	r8,0x1,COH
80002756:	c0 21       	brne	8000275a <scif_dfll0_openloop_start+0x5a>
80002758:	d5 03       	csrf	0x10

  // Wait for PCLKSR.DFLL0RDY is high
  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_DFLL0RDY_MASK))
8000275a:	e0 6c 40 00 	mov	r12,16384
8000275e:	f0 1f 00 11 	mcall	800027a0 <scif_dfll0_openloop_start+0xa0>
80002762:	c1 b1       	brne	80002798 <scif_dfll0_openloop_start+0x98>
    return -1;

  // Write DFLL0CONF.COARSE & DFLL0CONF.FINE
  u_avr32_scif_dfll0conf.DFLL0CONF.coarse = pdfllconfig->coarse;
80002764:	6c 18       	ld.w	r8,r6[0x4]
80002766:	ef d8 d3 08 	bfins	r7,r8,0x18,0x8
  u_avr32_scif_dfll0conf.DFLL0CONF.fine = pdfllconfig->fine;
8000276a:	6c 08       	ld.w	r8,r6[0x0]
8000276c:	ef d8 d1 09 	bfins	r7,r8,0x8,0x9
  AVR32_ENTER_CRITICAL_REGION( );
80002770:	e1 b9 00 00 	mfsr	r9,0x0
80002774:	d3 03       	ssrf	0x10
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
80002776:	fe 78 18 00 	mov	r8,-59392
8000277a:	32 4a       	mov	r10,36
8000277c:	ea 1a aa 00 	orh	r10,0xaa00
80002780:	91 6a       	st.w	r8[0x18],r10
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
80002782:	91 97       	st.w	r8[0x24],r7
  AVR32_LEAVE_CRITICAL_REGION( );
80002784:	12 98       	mov	r8,r9
80002786:	e6 18 00 01 	andh	r8,0x1,COH
8000278a:	c0 21       	brne	8000278e <scif_dfll0_openloop_start+0x8e>
8000278c:	d5 03       	csrf	0x10

  // Wait for PCLKSR.DFLL0RDY is high
  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_DFLL0RDY_MASK))
8000278e:	e0 6c 40 00 	mov	r12,16384
80002792:	f0 1f 00 04 	mcall	800027a0 <scif_dfll0_openloop_start+0xa0>
80002796:	c0 20       	breq	8000279a <scif_dfll0_openloop_start+0x9a>
80002798:	3f fc       	mov	r12,-1
    return -1;

  return PASS;
}
8000279a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000279e:	00 00       	add	r0,r0
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	26 e4       	sub	r4,110

800027a4 <spi_unlock_flash>:
#include "spifun.h"

int spi_unlock_flash(){
	int i, rx_data;
	//write enable
	*(volatile uint32_t*)0xFFFF400C = 0x06;	//send data to TX reg
800027a4:	30 69       	mov	r9,6
800027a6:	fe 78 40 0c 	mov	r8,-49140
800027aa:	91 09       	st.w	r8[0x0],r9
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
800027ac:	fe 78 40 10 	mov	r8,-49136
800027b0:	70 09       	ld.w	r9,r8[0x0]
800027b2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800027b6:	cf d0       	breq	800027b0 <spi_unlock_flash+0xc>
	rx_data = *((volatile uint32_t*)(0xFFFF4008));
800027b8:	fe 78 40 08 	mov	r8,-49144
800027bc:	70 08       	ld.w	r8,r8[0x0]
	
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_TXEMPTY_MASK) != AVR32_SPI_SR_TXEMPTY_MASK ); //wait for tx buffer to empty
800027be:	fe 78 40 10 	mov	r8,-49136
800027c2:	70 09       	ld.w	r9,r8[0x0]
800027c4:	e2 19 02 00 	andl	r9,0x200,COH
800027c8:	cf d0       	breq	800027c2 <spi_unlock_flash+0x1e>
	
	//write status enable
	*(volatile uint32_t*)0xFFFF400C = 0x06;	//send data to TX reg
800027ca:	30 69       	mov	r9,6
800027cc:	fe 78 40 0c 	mov	r8,-49140
800027d0:	91 09       	st.w	r8[0x0],r9
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
800027d2:	fe 78 40 10 	mov	r8,-49136
800027d6:	70 09       	ld.w	r9,r8[0x0]
800027d8:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800027dc:	cf d0       	breq	800027d6 <spi_unlock_flash+0x32>
	rx_data = *((volatile uint32_t*)(0xFFFF4008));
800027de:	fe 78 40 08 	mov	r8,-49144
800027e2:	70 08       	ld.w	r8,r8[0x0]
	
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_TXEMPTY_MASK) != AVR32_SPI_SR_TXEMPTY_MASK ); //wait for tx buffer to empty
800027e4:	fe 78 40 10 	mov	r8,-49136
800027e8:	70 09       	ld.w	r9,r8[0x0]
800027ea:	e2 19 02 00 	andl	r9,0x200,COH
800027ee:	cf d0       	breq	800027e8 <spi_unlock_flash+0x44>
	
	//set status reg to 0x00
	*(volatile uint32_t*)0xFFFF400C = (0x01);	//send data to TX reg
800027f0:	30 19       	mov	r9,1
800027f2:	fe 78 40 0c 	mov	r8,-49140
800027f6:	91 09       	st.w	r8[0x0],r9
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
800027f8:	fe 78 40 10 	mov	r8,-49136
800027fc:	70 09       	ld.w	r9,r8[0x0]
800027fe:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80002802:	cf d0       	breq	800027fc <spi_unlock_flash+0x58>
	rx_data = *((volatile uint32_t*)(0xFFFF4008));
80002804:	fe 78 40 08 	mov	r8,-49144
80002808:	70 08       	ld.w	r8,r8[0x0]
	
	*(volatile uint32_t*)0xFFFF400C = (0x00);	//send data to TX reg
8000280a:	30 09       	mov	r9,0
8000280c:	fe 78 40 0c 	mov	r8,-49140
80002810:	91 09       	st.w	r8[0x0],r9
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
80002812:	fe 78 40 10 	mov	r8,-49136
80002816:	70 09       	ld.w	r9,r8[0x0]
80002818:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000281c:	cf d0       	breq	80002816 <spi_unlock_flash+0x72>
	rx_data = *((volatile uint32_t*)(0xFFFF4008));
8000281e:	fe 78 40 08 	mov	r8,-49144
80002822:	70 08       	ld.w	r8,r8[0x0]
	
	return;
}
80002824:	5e fc       	retal	r12

80002826 <spi_read_flash>:
	}

	return;
}

unsigned int spi_read_flash(int addr32){
80002826:	d4 01       	pushm	lr
80002828:	20 2d       	sub	sp,8
	char addr2 = (char)((addr32 >> 16) & 0xFF);
	char addr1 = (char)((addr32 >> 8) & 0xFF);
	char addr0 = (char)((addr32 >> 0) & 0xFF);
	char read_sequence[5] = {(char)0x03,addr2,addr1,addr0,(char)0xFF};
8000282a:	30 38       	mov	r8,3
8000282c:	ba 88       	st.b	sp[0x0],r8
8000282e:	f8 08 14 10 	asr	r8,r12,0x10
80002832:	ba 98       	st.b	sp[0x1],r8
80002834:	f8 08 14 08 	asr	r8,r12,0x8
80002838:	ba a8       	st.b	sp[0x2],r8
8000283a:	ba bc       	st.b	sp[0x3],r12
8000283c:	3f f8       	mov	r8,-1
8000283e:	ba c8       	st.b	sp[0x4],r8
	int i, rx_data;
	for (i = 0; i < 5; i++){
		*(volatile uint32_t*)0xFFFF400C = (read_sequence[i]);	//send data to TX reg
80002840:	fe 78 40 0c 	mov	r8,-49140
80002844:	30 39       	mov	r9,3
80002846:	91 09       	st.w	r8[0x0],r9
80002848:	30 0a       	mov	r10,0
		if (i == 4){
			while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_TXEMPTY_MASK) != AVR32_SPI_SR_TXEMPTY_MASK );
		}
		while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
8000284a:	fe 79 40 10 	mov	r9,-49136
		rx_data = *((volatile uint32_t*)(0xFFFF4008));
8000284e:	fe 7b 40 08 	mov	r11,-49144
	char addr1 = (char)((addr32 >> 8) & 0xFF);
	char addr0 = (char)((addr32 >> 0) & 0xFF);
	char read_sequence[5] = {(char)0x03,addr2,addr1,addr0,(char)0xFF};
	int i, rx_data;
	for (i = 0; i < 5; i++){
		*(volatile uint32_t*)0xFFFF400C = (read_sequence[i]);	//send data to TX reg
80002852:	10 9e       	mov	lr,r8
80002854:	c0 d8       	rjmp	8000286e <spi_read_flash+0x48>
80002856:	fa c8 ff f8 	sub	r8,sp,-8
8000285a:	14 08       	add	r8,r10
8000285c:	f1 38 ff f8 	ld.ub	r8,r8[-8]
80002860:	9d 08       	st.w	lr[0x0],r8
		if (i == 4){
80002862:	58 4a       	cp.w	r10,4
80002864:	c0 51       	brne	8000286e <spi_read_flash+0x48>
			while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_TXEMPTY_MASK) != AVR32_SPI_SR_TXEMPTY_MASK );
80002866:	72 08       	ld.w	r8,r9[0x0]
80002868:	e2 18 02 00 	andl	r8,0x200,COH
8000286c:	cf d0       	breq	80002866 <spi_read_flash+0x40>
		}
		while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
8000286e:	72 08       	ld.w	r8,r9[0x0]
80002870:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002874:	cf d0       	breq	8000286e <spi_read_flash+0x48>
		rx_data = *((volatile uint32_t*)(0xFFFF4008));
80002876:	76 0c       	ld.w	r12,r11[0x0]
	char addr2 = (char)((addr32 >> 16) & 0xFF);
	char addr1 = (char)((addr32 >> 8) & 0xFF);
	char addr0 = (char)((addr32 >> 0) & 0xFF);
	char read_sequence[5] = {(char)0x03,addr2,addr1,addr0,(char)0xFF};
	int i, rx_data;
	for (i = 0; i < 5; i++){
80002878:	2f fa       	sub	r10,-1
8000287a:	58 4a       	cp.w	r10,4
8000287c:	fe 9a ff ed 	brle	80002856 <spi_read_flash+0x30>
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80002880:	30 09       	mov	r9,0
80002882:	fe 78 40 00 	mov	r8,-49152
80002886:	91 39       	st.w	r8[0xc],r9
		}
		while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK ); //wait for rx buffer to be full
		rx_data = *((volatile uint32_t*)(0xFFFF4008));
	}
	spi_put((uint32_t*)0xFFFF4000, 0x00);
	int dummy = *((volatile uint16_t*)(0xFFFF4008));
80002888:	fe 78 40 08 	mov	r8,-49144
8000288c:	90 08       	ld.sh	r8,r8[0x0]
	return (rx_data);
}
8000288e:	2f ed       	sub	sp,-8
80002890:	d8 02       	popm	pc

80002892 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002892:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002894:	f6 08 15 04 	lsl	r8,r11,0x4
80002898:	14 38       	cp.w	r8,r10
8000289a:	f9 b8 08 10 	movls	r8,16
8000289e:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800028a2:	f0 0b 02 4b 	mul	r11,r8,r11
800028a6:	f6 09 16 01 	lsr	r9,r11,0x1
800028aa:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800028ae:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800028b2:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800028b6:	f2 cb 00 01 	sub	r11,r9,1
800028ba:	e0 4b ff fe 	cp.w	r11,65534
800028be:	e0 88 00 03 	brls	800028c4 <usart_set_async_baudrate+0x32>
800028c2:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800028c4:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800028c6:	e8 6e 00 00 	mov	lr,524288
800028ca:	59 08       	cp.w	r8,16
800028cc:	fc 08 17 10 	movne	r8,lr
800028d0:	f9 b8 00 00 	moveq	r8,0
800028d4:	e4 1b ff f7 	andh	r11,0xfff7
800028d8:	e0 1b fe cf 	andl	r11,0xfecf
800028dc:	16 48       	or	r8,r11
800028de:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800028e0:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800028e4:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800028e8:	99 89       	st.w	r12[0x20],r9
800028ea:	d8 0a       	popm	pc,r12=0

800028ec <usart_write_char>:
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static inline int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800028ec:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800028ee:	e2 18 00 02 	andl	r8,0x2,COH
800028f2:	c0 31       	brne	800028f8 <usart_write_char+0xc>
800028f4:	30 2c       	mov	r12,2
800028f6:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800028f8:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800028fc:	99 7b       	st.w	r12[0x1c],r11
800028fe:	5e fd       	retal	0

80002900 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80002900:	eb cd 40 e0 	pushm	r5-r7,lr
80002904:	18 96       	mov	r6,r12
80002906:	16 95       	mov	r5,r11
80002908:	e0 67 27 0f 	mov	r7,9999
8000290c:	c0 68       	rjmp	80002918 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000290e:	58 07       	cp.w	r7,0
80002910:	c0 31       	brne	80002916 <usart_putchar+0x16>
80002912:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80002916:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80002918:	0a 9b       	mov	r11,r5
8000291a:	0c 9c       	mov	r12,r6
8000291c:	f0 1f 00 03 	mcall	80002928 <usart_putchar+0x28>
80002920:	cf 71       	brne	8000290e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80002922:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002926:	00 00       	add	r0,r0
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	28 ec       	sub	r12,-114

8000292c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000292c:	78 58       	ld.w	r8,r12[0x14]
8000292e:	e2 18 00 e0 	andl	r8,0xe0,COH
80002932:	c0 30       	breq	80002938 <usart_read_char+0xc>
80002934:	30 4c       	mov	r12,4
80002936:	5e fc       	retal	r12
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static inline int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80002938:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000293a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000293e:	c0 31       	brne	80002944 <usart_read_char+0x18>
80002940:	30 3c       	mov	r12,3
80002942:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80002944:	78 68       	ld.w	r8,r12[0x18]
80002946:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000294a:	97 08       	st.w	r11[0x0],r8
8000294c:	5e fd       	retal	0
8000294e:	d7 03       	nop

80002950 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80002950:	eb cd 40 c0 	pushm	r6-r7,lr
80002954:	20 1d       	sub	sp,4
80002956:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80002958:	1a 97       	mov	r7,sp
8000295a:	1a 9b       	mov	r11,sp
8000295c:	0c 9c       	mov	r12,r6
8000295e:	f0 1f 00 07 	mcall	80002978 <usart_getchar+0x28>
80002962:	58 3c       	cp.w	r12,3
80002964:	cf b0       	breq	8000295a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80002966:	58 4c       	cp.w	r12,4
80002968:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
8000296c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80002970:	2f fd       	sub	sp,-4
80002972:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002976:	00 00       	add	r0,r0
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	29 2c       	sub	r12,-110

8000297c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000297c:	eb cd 40 c0 	pushm	r6-r7,lr
80002980:	18 96       	mov	r6,r12
80002982:	16 97       	mov	r7,r11
  while (*string != '\0')
80002984:	17 8b       	ld.ub	r11,r11[0x0]
80002986:	58 0b       	cp.w	r11,0
80002988:	c0 80       	breq	80002998 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000298a:	2f f7       	sub	r7,-1
8000298c:	0c 9c       	mov	r12,r6
8000298e:	f0 1f 00 04 	mcall	8000299c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80002992:	0f 8b       	ld.ub	r11,r7[0x0]
80002994:	58 0b       	cp.w	r11,0
80002996:	cf a1       	brne	8000298a <usart_write_line+0xe>
80002998:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	29 00       	sub	r0,-112

800029a0 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800029a0:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800029a4:	e6 18 00 01 	andh	r8,0x1,COH
800029a8:	c0 71       	brne	800029b6 <usart_reset+0x16>
800029aa:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800029ac:	3f f8       	mov	r8,-1
800029ae:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800029b0:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800029b2:	d5 03       	csrf	0x10
800029b4:	c0 48       	rjmp	800029bc <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800029b6:	3f f8       	mov	r8,-1
800029b8:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800029ba:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800029bc:	30 08       	mov	r8,0
800029be:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800029c0:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800029c2:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800029c4:	e8 68 61 0c 	mov	r8,549132
800029c8:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800029ca:	5e fc       	retal	r12

800029cc <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800029cc:	eb cd 40 e0 	pushm	r5-r7,lr
800029d0:	18 96       	mov	r6,r12
800029d2:	16 97       	mov	r7,r11
800029d4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800029d6:	f0 1f 00 2f 	mcall	80002a90 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800029da:	58 07       	cp.w	r7,0
800029dc:	c5 80       	breq	80002a8c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800029de:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800029e0:	30 49       	mov	r9,4
800029e2:	f2 08 18 00 	cp.b	r8,r9
800029e6:	e0 88 00 53 	brls	80002a8c <usart_init_rs232+0xc0>
800029ea:	30 99       	mov	r9,9
800029ec:	f2 08 18 00 	cp.b	r8,r9
800029f0:	e0 8b 00 4e 	brhi	80002a8c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800029f4:	0f d9       	ld.ub	r9,r7[0x5]
800029f6:	30 78       	mov	r8,7
800029f8:	f0 09 18 00 	cp.b	r9,r8
800029fc:	e0 8b 00 48 	brhi	80002a8c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80002a00:	8e 39       	ld.sh	r9,r7[0x6]
80002a02:	e0 68 01 01 	mov	r8,257
80002a06:	f0 09 19 00 	cp.h	r9,r8
80002a0a:	e0 8b 00 41 	brhi	80002a8c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80002a0e:	ef 39 00 08 	ld.ub	r9,r7[8]
80002a12:	30 38       	mov	r8,3
80002a14:	f0 09 18 00 	cp.b	r9,r8
80002a18:	e0 8b 00 3a 	brhi	80002a8c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002a1c:	0a 9a       	mov	r10,r5
80002a1e:	6e 0b       	ld.w	r11,r7[0x0]
80002a20:	0c 9c       	mov	r12,r6
80002a22:	f0 1f 00 1d 	mcall	80002a94 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002a26:	58 1c       	cp.w	r12,1
80002a28:	c3 20       	breq	80002a8c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80002a2a:	0f c8       	ld.ub	r8,r7[0x4]
80002a2c:	30 99       	mov	r9,9
80002a2e:	f2 08 18 00 	cp.b	r8,r9
80002a32:	c0 51       	brne	80002a3c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002a34:	6c 18       	ld.w	r8,r6[0x4]
80002a36:	b1 b8       	sbr	r8,0x11
80002a38:	8d 18       	st.w	r6[0x4],r8
80002a3a:	c0 68       	rjmp	80002a46 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002a3c:	6c 19       	ld.w	r9,r6[0x4]
80002a3e:	20 58       	sub	r8,5
80002a40:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80002a44:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002a46:	6c 19       	ld.w	r9,r6[0x4]
80002a48:	ef 3a 00 08 	ld.ub	r10,r7[8]
80002a4c:	0f d8       	ld.ub	r8,r7[0x5]
80002a4e:	a9 78       	lsl	r8,0x9
80002a50:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80002a54:	12 48       	or	r8,r9
80002a56:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002a58:	8e 38       	ld.sh	r8,r7[0x6]
80002a5a:	30 29       	mov	r9,2
80002a5c:	f2 08 19 00 	cp.h	r8,r9
80002a60:	e0 88 00 09 	brls	80002a72 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002a64:	6c 18       	ld.w	r8,r6[0x4]
80002a66:	ad b8       	sbr	r8,0xd
80002a68:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002a6a:	8e b8       	ld.uh	r8,r7[0x6]
80002a6c:	20 28       	sub	r8,2
80002a6e:	8d a8       	st.w	r6[0x28],r8
80002a70:	c0 68       	rjmp	80002a7c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80002a72:	6c 19       	ld.w	r9,r6[0x4]
80002a74:	5c 78       	castu.h	r8
80002a76:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80002a7a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80002a7c:	6c 18       	ld.w	r8,r6[0x4]
80002a7e:	e0 18 ff f0 	andl	r8,0xfff0
80002a82:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002a84:	35 08       	mov	r8,80
80002a86:	8d 08       	st.w	r6[0x0],r8
80002a88:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002a8c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	29 a0       	sub	r0,-102
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	28 92       	sub	r2,-119

80002a98 <_stext>:
80002a98:	48 dd       	lddpc	sp,80002acc <udata_clear_loop_end+0x4>
80002a9a:	fe c0 fa 9a 	sub	r0,pc,-1382
80002a9e:	e3 b0 00 01 	mtsr	0x4,r0
80002aa2:	d5 53       	csrf	0x15
80002aa4:	48 b0       	lddpc	r0,80002ad0 <udata_clear_loop_end+0x8>
80002aa6:	48 c1       	lddpc	r1,80002ad4 <udata_clear_loop_end+0xc>
80002aa8:	02 30       	cp.w	r0,r1
80002aaa:	c0 62       	brcc	80002ab6 <idata_load_loop_end>
80002aac:	48 b2       	lddpc	r2,80002ad8 <udata_clear_loop_end+0x10>

80002aae <idata_load_loop>:
80002aae:	a5 05       	ld.d	r4,r2++
80002ab0:	a1 24       	st.d	r0++,r4
80002ab2:	02 30       	cp.w	r0,r1
80002ab4:	cf d3       	brcs	80002aae <idata_load_loop>

80002ab6 <idata_load_loop_end>:
80002ab6:	48 a0       	lddpc	r0,80002adc <udata_clear_loop_end+0x14>
80002ab8:	48 a1       	lddpc	r1,80002ae0 <udata_clear_loop_end+0x18>
80002aba:	02 30       	cp.w	r0,r1
80002abc:	c0 62       	brcc	80002ac8 <udata_clear_loop_end>
80002abe:	30 02       	mov	r2,0
80002ac0:	30 03       	mov	r3,0

80002ac2 <udata_clear_loop>:
80002ac2:	a1 22       	st.d	r0++,r2
80002ac4:	02 30       	cp.w	r0,r1
80002ac6:	cf e3       	brcs	80002ac2 <udata_clear_loop>

80002ac8 <udata_clear_loop_end>:
80002ac8:	fe cf fe 4c 	sub	pc,pc,-436
80002acc:	00 00       	add	r0,r0
80002ace:	80 00       	ld.sh	r0,r0[0x0]
80002ad0:	00 00       	add	r0,r0
80002ad2:	00 04       	add	r4,r0
80002ad4:	00 00       	add	r0,r0
80002ad6:	00 10       	sub	r0,r0
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	33 d8       	mov	r8,61
80002adc:	00 00       	add	r0,r0
80002ade:	00 10       	sub	r0,r0
80002ae0:	00 00       	add	r0,r0
80002ae2:	00 f8       	st.b	--r0,r8

80002ae4 <gpioClock>:
	pm_set_mclk_source(PM_CLK_SRC_DFLL0);
	
}

#define AVR32_GC_DIV_CLOCK                             0x00000001
void gpioClock() {
80002ae4:	d4 01       	pushm	lr
	// Note: for UC3L devices, the generic clock configurations are handled by the
	// SCIF module.
	// Setup gc to use the DFLL0 as source clock, divisor enabled, apply a division factor.
	// Since the DFLL0 frequency is 96MHz, set the division factor to 2 to have a
	// gclk frequency of 48MHz.
	scif_gc_setup(AVR32_SCIF_GCLK_DFLL0_SSG, SCIF_GCCTRL_DFLL0, AVR32_GC_DIV_CLOCK, 2);
80002ae6:	30 29       	mov	r9,2
80002ae8:	30 1a       	mov	r10,1
80002aea:	12 9b       	mov	r11,r9
80002aec:	14 9c       	mov	r12,r10
80002aee:	f0 1f 00 06 	mcall	80002b04 <gpioClock+0x20>

	/* Now enable the generic clock */
	scif_gc_enable(AVR32_SCIF_GCLK_DFLL0_SSG);
80002af2:	30 1c       	mov	r12,1
80002af4:	f0 1f 00 05 	mcall	80002b08 <gpioClock+0x24>
	
	/* Set the GCLOCK function to the GPIO pin */
	gpio_enable_module_pin(AVR32_SCIF_GCLK_1_0_PIN, AVR32_SCIF_GCLK_1_0_FUNCTION);
80002af8:	30 6b       	mov	r11,6
80002afa:	16 9c       	mov	r12,r11
80002afc:	f0 1f 00 04 	mcall	80002b0c <gpioClock+0x28>
80002b00:	d8 02       	popm	pc
80002b02:	00 00       	add	r0,r0
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	26 48       	sub	r8,100
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	26 c0       	sub	r0,108
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	22 0c       	sub	r12,32

80002b10 <initClock>:
	gpio_configure_pin(AVR32_PIN_PA22, init_b_config);
	gpio_configure_pin(AVR32_PIN_PB10, done_config);
	 
}

void initClock() {
80002b10:	d4 01       	pushm	lr
80002b12:	20 2d       	sub	sp,8
	scif_dfll_openloop_conf_t dfllconfig ={150,65};
80002b14:	e0 68 00 96 	mov	r8,150
80002b18:	50 08       	stdsp	sp[0x0],r8
80002b1a:	34 18       	mov	r8,65
80002b1c:	50 18       	stdsp	sp[0x4],r8
	
	// Configure and start the DFLL0 in open loop mode to generate a frequency of 96MHz.
	scif_dfll0_openloop_start(&dfllconfig);
80002b1e:	1a 9c       	mov	r12,sp
80002b20:	f0 1f 00 0d 	mcall	80002b54 <initClock+0x44>

	// Since our target is to set the CPU&HSB frequency domains to 48MHz, we must
	// set one wait-state and enable the High-speed read mode on the flash controller.
	flashcdw_set_flash_waitstate_and_readmode((48000000UL));
80002b24:	e0 6c 6c 00 	mov	r12,27648
80002b28:	ea 1c 02 dc 	orh	r12,0x2dc
80002b2c:	f0 1f 00 0b 	mcall	80002b58 <initClock+0x48>

	// Set the CPU clock domain to 48MHz (by applying a division ratio = 2).
	pm_set_clk_domain_div((pm_clk_domain_t)AVR32_PM_CLK_GRP_CPU, PM_CKSEL_DIVRATIO_2);
80002b30:	30 0b       	mov	r11,0
80002b32:	16 9c       	mov	r12,r11
80002b34:	f0 1f 00 0a 	mcall	80002b5c <initClock+0x4c>

	// Set the PBA clock domain to 24MHz (by applying a division ratio = 4).
	pm_set_clk_domain_div((pm_clk_domain_t)AVR32_PM_CLK_GRP_PBA, PM_CKSEL_DIVRATIO_4);
80002b38:	30 1b       	mov	r11,1
80002b3a:	30 2c       	mov	r12,2
80002b3c:	f0 1f 00 08 	mcall	80002b5c <initClock+0x4c>

	// Set the PBB clock domain to 48MHz (by applying a division ratio = 2).
	pm_set_clk_domain_div((pm_clk_domain_t)AVR32_PM_CLK_GRP_PBB, PM_CKSEL_DIVRATIO_2);
80002b40:	30 0b       	mov	r11,0
80002b42:	30 3c       	mov	r12,3
80002b44:	f0 1f 00 06 	mcall	80002b5c <initClock+0x4c>

	// Set the main clock source to be DFLL0.
	pm_set_mclk_source(PM_CLK_SRC_DFLL0);
80002b48:	30 2c       	mov	r12,2
80002b4a:	f0 1f 00 06 	mcall	80002b60 <initClock+0x50>
	
}
80002b4e:	2f ed       	sub	sp,-8
80002b50:	d8 02       	popm	pc
80002b52:	00 00       	add	r0,r0
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	27 00       	sub	r0,112
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	20 78       	sub	r8,7
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	25 ac       	sub	r12,90
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	25 f6       	sub	r6,95

80002b64 <board_init>:
#define WRITE_CR(val) ((*(volatile uint32_t *)0xFFFF4000) = (val))
#define WRITE_CS0(val) ((*(volatile uint32_t *)0xFFFF4030) = (val))
#define WRITE_CS3(val) ((*(volatile uint32_t *)0xFFFF403C) = (val))

void board_init(void)
{
80002b64:	eb cd 40 80 	pushm	r7,lr
	//uint32_t *GCLK0_CONTROL_BASE = (uint32_t*)0xFFFF1870;
	//*GCLK0_CONTROL_BASE = 0x00000001;
	//gpio_enable_module_pin(AVR32_SCIF_GCLK_0_1_PIN, AVR32_SCIF_GCLK_0_1_FUNCTION);

//init GPIO
	gpio_enable_gpio_pin(AVR32_PIN_PA15);
80002b68:	30 fc       	mov	r12,15
80002b6a:	f0 1f 00 3f 	mcall	80002c64 <board_init+0x100>
	gpio_enable_gpio_pin(AVR32_PIN_PA16);
80002b6e:	31 0c       	mov	r12,16
80002b70:	f0 1f 00 3d 	mcall	80002c64 <board_init+0x100>

//Initial SPI pins
	gpio_enable_module_pin(AVR32_SPI_SCK_0_1_PIN, AVR32_SPI_SCK_0_1_FUNCTION);				//Enable SCK
80002b74:	30 2b       	mov	r11,2
80002b76:	32 1c       	mov	r12,33
80002b78:	f0 1f 00 3c 	mcall	80002c68 <board_init+0x104>
	gpio_enable_module_pin(AVR32_SPI_MOSI_0_1_PIN, AVR32_SPI_MOSI_0_1_FUNCTION);			//Enable MOSI
80002b7c:	30 2b       	mov	r11,2
80002b7e:	32 3c       	mov	r12,35
80002b80:	f0 1f 00 3a 	mcall	80002c68 <board_init+0x104>
	gpio_enable_module_pin(AVR32_SPI_MISO_0_1_PIN, AVR32_SPI_MISO_0_1_FUNCTION);			//Enable MISO
80002b84:	30 2b       	mov	r11,2
80002b86:	32 2c       	mov	r12,34
80002b88:	f0 1f 00 38 	mcall	80002c68 <board_init+0x104>
	gpio_enable_module_pin(AVR32_SPI_NPCS_0_1_PIN, AVR32_SPI_NPCS_0_1_FUNCTION);			//Enable CS0 (FLASH)
80002b8c:	30 2b       	mov	r11,2
80002b8e:	32 0c       	mov	r12,32
80002b90:	f0 1f 00 36 	mcall	80002c68 <board_init+0x104>
	gpio_enable_module_pin(AVR32_SPI_NPCS_2_0_PIN, AVR32_SPI_NPCS_2_0_FUNCTION);			//Enable CS2 (FPGA1)
80002b94:	30 1b       	mov	r11,1
80002b96:	30 8c       	mov	r12,8
80002b98:	f0 1f 00 34 	mcall	80002c68 <board_init+0x104>
	gpio_enable_module_pin(AVR32_SPI_NPCS_3_0_PIN, AVR32_SPI_NPCS_3_0_FUNCTION);			//Enable CS3 (FPGA2)
80002b9c:	30 1b       	mov	r11,1
80002b9e:	30 9c       	mov	r12,9
80002ba0:	f0 1f 00 32 	mcall	80002c68 <board_init+0x104>
	uint32_t *SPI_BASE = (volatile uint32_t*)0xFFFF4000;
	//*(SPI_BASE+0x04) = 0x00000053;				//init mode register
	//*(SPI_BASE+0x30) = 0x00000202;				//init cs0 register
	//*(SPI_BASE+0x00) = 0x00000001;
	//WRITE_MR(0x00000013);
	WRITE_MR(0x000E0011);
80002ba4:	ee 69 00 11 	mov	r9,917521
80002ba8:	fe 78 40 04 	mov	r8,-49148
80002bac:	91 09       	st.w	r8[0x0],r9
	WRITE_CS0(0x00000502);
80002bae:	e0 68 05 02 	mov	r8,1282
80002bb2:	fe 79 40 30 	mov	r9,-49104
80002bb6:	93 08       	st.w	r9[0x0],r8
	WRITE_CS3(0x00000502);
80002bb8:	fe 79 40 3c 	mov	r9,-49092
80002bbc:	93 08       	st.w	r9[0x0],r8
	WRITE_CR(0x00000001);
80002bbe:	30 17       	mov	r7,1
80002bc0:	fe 78 40 00 	mov	r8,-49152
80002bc4:	91 07       	st.w	r8[0x0],r7
	

//Initialize UART pins

	//UART 2 is General Purpose
	gpio_enable_module_pin(AVR32_USART2_TXD_0_0_PIN, AVR32_USART2_TXD_0_0_FUNCTION);			//UART 2 TX
80002bc6:	30 0b       	mov	r11,0
80002bc8:	31 4c       	mov	r12,20
80002bca:	f0 1f 00 28 	mcall	80002c68 <board_init+0x104>
	gpio_enable_module_pin(AVR32_USART2_RXD_0_0_PIN, AVR32_USART2_RXD_0_0_FUNCTION);			//UART 2 RX
80002bce:	30 0b       	mov	r11,0
80002bd0:	31 5c       	mov	r12,21
80002bd2:	f0 1f 00 26 	mcall	80002c68 <board_init+0x104>
	uint32_t *USART2_BASE_ADDR = (uint32_t*)0xFFFF3800;
	
	
	//UART 3 is used to communicate with PC
	gpio_enable_module_pin(AVR32_USART3_TXD_0_1_PIN, AVR32_USART3_TXD_0_1_FUNCTION);			//UART 3 TX
80002bd6:	0e 9b       	mov	r11,r7
80002bd8:	32 6c       	mov	r12,38
80002bda:	f0 1f 00 24 	mcall	80002c68 <board_init+0x104>
	gpio_enable_module_pin(AVR32_USART3_RXD_0_1_PIN, AVR32_USART3_RXD_0_1_FUNCTION);			//UART 3 RX
80002bde:	0e 9b       	mov	r11,r7
80002be0:	32 7c       	mov	r12,39
80002be2:	f0 1f 00 22 	mcall	80002c68 <board_init+0x104>
		.paritytype = USART_NO_PARITY,
		.stopbits = USART_1_STOPBIT,
		.channelmode = USART_NORMAL_CHMODE
	};
	
	usart_init_rs232(USART3_BASE_ADDR, &USART_OPTIONS, 17200000);
80002be6:	e0 6a 73 80 	mov	r10,29568
80002bea:	ea 1a 01 06 	orh	r10,0x106
80002bee:	4a 0b       	lddpc	r11,80002c6c <board_init+0x108>
80002bf0:	fe 7c 3c 00 	mov	r12,-50176
80002bf4:	f0 1f 00 1f 	mcall	80002c70 <board_init+0x10c>
	usart_init_rs232(USART2_BASE_ADDR, &USART_OPTIONS2, 17200000);
80002bf8:	e0 6a 73 80 	mov	r10,29568
80002bfc:	ea 1a 01 06 	orh	r10,0x106
80002c00:	49 db       	lddpc	r11,80002c74 <board_init+0x110>
80002c02:	fe 7c 38 00 	mov	r12,-51200
80002c06:	f0 1f 00 1b 	mcall	80002c70 <board_init+0x10c>
		.chip = 0x55,
		.smbus = false
	};
*/
	
	gpio_enable_module_pin(AVR32_TWIMS1_TWCK_0_1_PIN, 6);			//enable i2c clk
80002c0a:	30 6b       	mov	r11,6
80002c0c:	32 4c       	mov	r12,36
80002c0e:	f0 1f 00 17 	mcall	80002c68 <board_init+0x104>
	gpio_enable_module_pin(AVR32_TWIMS1_TWD_0_PIN, AVR32_TWIMS1_TWD_0_FUNCTION);  //enable i2c data
80002c12:	30 3b       	mov	r11,3
80002c14:	31 1c       	mov	r12,17
80002c16:	f0 1f 00 15 	mcall	80002c68 <board_init+0x104>
	//twim_master_init(TWIM1_BASE, &TWIM_OPTIONS); //have to initialize in main because the right clock frequency isnt set yet
	
//Initialize FGPA config pins
	gpio_enable_gpio_pin(AVR32_PIN_PB05);					//init CCLK
80002c1a:	32 5c       	mov	r12,37
80002c1c:	f0 1f 00 12 	mcall	80002c64 <board_init+0x100>
	gpio_enable_gpio_pin(AVR32_PIN_PA05);					//init DIN
80002c20:	30 5c       	mov	r12,5
80002c22:	f0 1f 00 11 	mcall	80002c64 <board_init+0x100>
	gpio_enable_gpio_pin(AVR32_PIN_PA11);					//init PROGRAM_B
80002c26:	30 bc       	mov	r12,11
80002c28:	f0 1f 00 0f 	mcall	80002c64 <board_init+0x100>
	gpio_enable_gpio_pin(AVR32_PIN_PA22);					//init INIT_B
80002c2c:	31 6c       	mov	r12,22
80002c2e:	f0 1f 00 0e 	mcall	80002c64 <board_init+0x100>
	gpio_enable_gpio_pin(AVR32_PIN_PB10);					//init DONE
80002c32:	32 ac       	mov	r12,42
80002c34:	f0 1f 00 0c 	mcall	80002c64 <board_init+0x100>
	uint32_t program_b_config = GPIO_DIR_OUTPUT | GPIO_INIT_HIGH;
	uint32_t init_b_config = GPIO_DIR_INPUT;
	uint32_t done_config = GPIO_DIR_INPUT;
	
	//set pins as input/output
	gpio_configure_pin(AVR32_PIN_PB05, cclk_config);
80002c38:	0e 9b       	mov	r11,r7
80002c3a:	32 5c       	mov	r12,37
80002c3c:	f0 1f 00 0f 	mcall	80002c78 <board_init+0x114>
	gpio_configure_pin(AVR32_PIN_PA05, din_config);
80002c40:	0e 9b       	mov	r11,r7
80002c42:	30 5c       	mov	r12,5
80002c44:	f0 1f 00 0d 	mcall	80002c78 <board_init+0x114>
	gpio_configure_pin(AVR32_PIN_PA11, program_b_config);
80002c48:	30 3b       	mov	r11,3
80002c4a:	30 bc       	mov	r12,11
80002c4c:	f0 1f 00 0b 	mcall	80002c78 <board_init+0x114>
	gpio_configure_pin(AVR32_PIN_PA22, init_b_config);
80002c50:	30 0b       	mov	r11,0
80002c52:	31 6c       	mov	r12,22
80002c54:	f0 1f 00 09 	mcall	80002c78 <board_init+0x114>
	gpio_configure_pin(AVR32_PIN_PB10, done_config);
80002c58:	30 0b       	mov	r11,0
80002c5a:	32 ac       	mov	r12,42
80002c5c:	f0 1f 00 07 	mcall	80002c78 <board_init+0x114>
	 
}
80002c60:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c64:	80 00       	ld.sh	r0,r0[0x0]
80002c66:	22 a0       	sub	r0,42
80002c68:	80 00       	ld.sh	r0,r0[0x0]
80002c6a:	22 0c       	sub	r12,32
80002c6c:	80 00       	ld.sh	r0,r0[0x0]
80002c6e:	33 50       	mov	r0,53
80002c70:	80 00       	ld.sh	r0,r0[0x0]
80002c72:	29 cc       	sub	r12,-100
80002c74:	80 00       	ld.sh	r0,r0[0x0]
80002c76:	33 5c       	mov	r12,53
80002c78:	80 00       	ld.sh	r0,r0[0x0]
80002c7a:	22 ce       	sub	lr,44

80002c7c <main>:
		.chip = TARGET_ADDRESS,
		.smbus = true
};	

int main (void)
{
80002c7c:	eb cd 40 f8 	pushm	r3-r7,lr
	board_init();
80002c80:	f0 1f 00 57 	mcall	80002ddc <main+0x160>
	initClock();						// set clock to 48MHz
80002c84:	f0 1f 00 57 	mcall	80002de0 <main+0x164>
	gpioClock();						// output clock to gpio pin 6
80002c88:	f0 1f 00 57 	mcall	80002de4 <main+0x168>
		
	//enable write for flash chip
	spi_put(SPI_BASE_MAIN, 0x06);
80002c8c:	4d 78       	lddpc	r8,80002de8 <main+0x16c>
80002c8e:	70 08       	ld.w	r8,r8[0x0]
80002c90:	30 69       	mov	r9,6
80002c92:	91 39       	st.w	r8[0xc],r9
	clr_rx = *((volatile uint16_t*)(0xFFFF4008));
80002c94:	fe 78 40 08 	mov	r8,-49144
80002c98:	90 09       	ld.sh	r9,r8[0x0]
80002c9a:	5c 79       	castu.h	r9
80002c9c:	4d 48       	lddpc	r8,80002dec <main+0x170>
80002c9e:	91 09       	st.w	r8[0x0],r9
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK );
80002ca0:	fe 78 40 10 	mov	r8,-49136
80002ca4:	70 09       	ld.w	r9,r8[0x0]
80002ca6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80002caa:	cf d0       	breq	80002ca4 <main+0x28>
	spi_unlock_flash();
80002cac:	f0 1f 00 51 	mcall	80002df0 <main+0x174>
	while ( (*((volatile uint32_t*)(0xFFFF4010)) & AVR32_SPI_SR_RDRF_MASK) != AVR32_SPI_SR_RDRF_MASK );
80002cb0:	fe 78 40 10 	mov	r8,-49136
80002cb4:	70 09       	ld.w	r9,r8[0x0]
80002cb6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80002cba:	cf d0       	breq	80002cb4 <main+0x38>
	
	//config FPGA
	//unsigned int file_length = program_flash();
	//echo_back_flash_data(file_length);
	
	usart_write_line(USART3_BASE_ADDR, "reading file length from flash...\r\n");
80002cbc:	4c e7       	lddpc	r7,80002df4 <main+0x178>
80002cbe:	4c fb       	lddpc	r11,80002df8 <main+0x17c>
80002cc0:	6e 0c       	ld.w	r12,r7[0x0]
80002cc2:	f0 1f 00 4f 	mcall	80002dfc <main+0x180>
	uint32_t file_length00 = 0;
	uint32_t file_length3,file_length2,file_length1,file_length0;
	file_length3 = (uint32_t)spi_read_flash(0) & 0x000000FF;						//program_flash();
80002cc6:	30 0c       	mov	r12,0
80002cc8:	f0 1f 00 4e 	mcall	80002e00 <main+0x184>
80002ccc:	eb dc c0 08 	bfextu	r5,r12,0x0,0x8
	send_binary_to_terminal(file_length3);
80002cd0:	0a 9c       	mov	r12,r5
80002cd2:	f0 1f 00 4d 	mcall	80002e04 <main+0x188>
	file_length2 = (uint32_t)spi_read_flash(1) & 0x000000FF;
80002cd6:	30 1c       	mov	r12,1
80002cd8:	f0 1f 00 4a 	mcall	80002e00 <main+0x184>
80002cdc:	ed dc c0 08 	bfextu	r6,r12,0x0,0x8
	send_binary_to_terminal(file_length2);
80002ce0:	0c 9c       	mov	r12,r6
80002ce2:	f0 1f 00 49 	mcall	80002e04 <main+0x188>
	file_length1 = (uint32_t)spi_read_flash(2) & 0x000000FF;
80002ce6:	30 2c       	mov	r12,2
80002ce8:	f0 1f 00 46 	mcall	80002e00 <main+0x184>
80002cec:	e7 dc c0 08 	bfextu	r3,r12,0x0,0x8
	send_binary_to_terminal(file_length1);
80002cf0:	06 9c       	mov	r12,r3
80002cf2:	f0 1f 00 45 	mcall	80002e04 <main+0x188>
	file_length0 = (uint32_t)spi_read_flash(3) & 0x000000FF;
80002cf6:	30 3c       	mov	r12,3
80002cf8:	f0 1f 00 42 	mcall	80002e00 <main+0x184>
80002cfc:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
	send_binary_to_terminal(file_length0);
80002d00:	08 9c       	mov	r12,r4
80002d02:	f0 1f 00 41 	mcall	80002e04 <main+0x188>
	file_length00 = file_length3<<24 | file_length2<<16 | file_length1<<8 | file_length0<<0 | 0;
	usart_putchar(USART3_BASE_ADDR, 0x0D);
80002d06:	30 db       	mov	r11,13
80002d08:	6e 0c       	ld.w	r12,r7[0x0]
80002d0a:	f0 1f 00 40 	mcall	80002e08 <main+0x18c>
	usart_putchar(USART3_BASE_ADDR, 0x0A);
80002d0e:	30 ab       	mov	r11,10
80002d10:	6e 0c       	ld.w	r12,r7[0x0]
80002d12:	f0 1f 00 3e 	mcall	80002e08 <main+0x18c>
	
	usart_write_line(USART3_BASE_ADDR, "Configuring FPGA...\r\n");
80002d16:	4b eb       	lddpc	r11,80002e0c <main+0x190>
80002d18:	6e 0c       	ld.w	r12,r7[0x0]
80002d1a:	f0 1f 00 39 	mcall	80002dfc <main+0x180>
	int is_not_configured = configure_fpga(file_length00);
80002d1e:	ec 0c 15 10 	lsl	r12,r6,0x10
80002d22:	f9 e5 11 8c 	or	r12,r12,r5<<0x18
80002d26:	08 4c       	or	r12,r4
80002d28:	f9 e3 10 8c 	or	r12,r12,r3<<0x8
80002d2c:	f0 1f 00 39 	mcall	80002e10 <main+0x194>
	
	if (is_not_configured == 1){
80002d30:	58 1c       	cp.w	r12,1
80002d32:	c0 61       	brne	80002d3e <main+0xc2>
		usart_write_line(USART3_BASE_ADDR, "Configuration Failed\r\n");
80002d34:	4b 8b       	lddpc	r11,80002e14 <main+0x198>
80002d36:	6e 0c       	ld.w	r12,r7[0x0]
80002d38:	f0 1f 00 31 	mcall	80002dfc <main+0x180>
80002d3c:	c0 68       	rjmp	80002d48 <main+0xcc>
	} else {
		usart_write_line(USART3_BASE_ADDR, "Configuration Complete!\r\n");
80002d3e:	4b 7b       	lddpc	r11,80002e18 <main+0x19c>
80002d40:	4a d8       	lddpc	r8,80002df4 <main+0x178>
80002d42:	70 0c       	ld.w	r12,r8[0x0]
80002d44:	f0 1f 00 2e 	mcall	80002dfc <main+0x180>
	}
	gpio_enable_gpio_pin(AVR32_PIN_PA17);
80002d48:	31 1c       	mov	r12,17
80002d4a:	f0 1f 00 35 	mcall	80002e1c <main+0x1a0>
	gpio_enable_pin_pull_up(AVR32_PIN_PA17);
80002d4e:	31 1c       	mov	r12,17
80002d50:	f0 1f 00 34 	mcall	80002e20 <main+0x1a4>
	gpio_enable_pin_pull_up(AVR32_PIN_PB04);
80002d54:	32 4c       	mov	r12,36
80002d56:	f0 1f 00 33 	mcall	80002e20 <main+0x1a4>
	//gpio_enable_module_pin(AVR32_TWIMS0_TWD_0_2_PIN, 6);
	//gpio_enable_module_pin(AVR32_TWIMS0_TWCK_0_2_PIN, AVR32_TWIMS0_TWCK_0_2_FUNCTION);
	gpio_enable_module_pin(AVR32_TWIMS1_TWCK_0_1_PIN, 6);			//enable i2c clk
80002d5a:	30 6b       	mov	r11,6
80002d5c:	32 4c       	mov	r12,36
80002d5e:	f0 1f 00 32 	mcall	80002e24 <main+0x1a8>
	gpio_enable_module_pin(AVR32_TWIMS1_TWD_0_PIN, AVR32_TWIMS1_TWD_0_FUNCTION);
80002d62:	30 3b       	mov	r11,3
80002d64:	31 1c       	mov	r12,17
80002d66:	f0 1f 00 30 	mcall	80002e24 <main+0x1a8>
	send_binary_to_terminal(*((volatile uint32_t*)(0xFFFF481C))>>16);
80002d6a:	fe 77 48 1c 	mov	r7,-47076
80002d6e:	6e 0c       	ld.w	r12,r7[0x0]
80002d70:	b1 8c       	lsr	r12,0x10
80002d72:	f0 1f 00 25 	mcall	80002e04 <main+0x188>
	send_binary_to_terminal(*((volatile uint32_t*)(0xFFFF481C))>>8);
80002d76:	6e 0c       	ld.w	r12,r7[0x0]
80002d78:	a9 8c       	lsr	r12,0x8
80002d7a:	f0 1f 00 23 	mcall	80002e04 <main+0x188>
	send_binary_to_terminal(*((volatile uint32_t*)(0xFFFF481C)));
80002d7e:	6e 0c       	ld.w	r12,r7[0x0]
80002d80:	f0 1f 00 21 	mcall	80002e04 <main+0x188>
	i2c_init();
80002d84:	f0 1f 00 29 	mcall	80002e28 <main+0x1ac>
	send_binary_to_terminal(*((volatile uint32_t*)(0xFFFF481C))>>16);
80002d88:	6e 0c       	ld.w	r12,r7[0x0]
80002d8a:	b1 8c       	lsr	r12,0x10
80002d8c:	f0 1f 00 1e 	mcall	80002e04 <main+0x188>
	send_binary_to_terminal(*((volatile uint32_t*)(0xFFFF481C))>>8);
80002d90:	6e 0c       	ld.w	r12,r7[0x0]
80002d92:	a9 8c       	lsr	r12,0x8
80002d94:	f0 1f 00 1c 	mcall	80002e04 <main+0x188>
	send_binary_to_terminal(*((volatile uint32_t*)(0xFFFF481C)));
80002d98:	6e 0c       	ld.w	r12,r7[0x0]
80002d9a:	f0 1f 00 1b 	mcall	80002e04 <main+0x188>
	*((volatile uint32_t*)(0xFFFF481C)) = 0x400;
80002d9e:	e0 68 04 00 	mov	r8,1024
80002da2:	8f 08       	st.w	r7[0x0],r8
	WRITE_MR(0x00070011);
80002da4:	e6 79 00 11 	mov	r9,458769
80002da8:	fe 78 40 04 	mov	r8,-49148
80002dac:	91 09       	st.w	r8[0x0],r9
	//set_adc_sample_rate(1,400);
	//set_adc_sample_rate(2,400);
	//set_adc_ce(3, 1,adc_ce_reg_pointer);
	
	while (1) {
		int uart_data = usart_getchar(USART3_BASE_ADDR) & 0xFF;						//wait for uart data
80002dae:	49 26       	lddpc	r6,80002df4 <main+0x178>
		usart_putchar(USART3_BASE_ADDR, uart_data);									//echo back data
		//gpio_enable_gpio_pin(AVR32_PIN_PA17);
		spi_write_FPGA(0, 0x80, (uart_data-48));									//write data to LED control reg
80002db0:	e0 65 00 80 	mov	r5,128
80002db4:	30 04       	mov	r4,0
	//set_adc_sample_rate(1,400);
	//set_adc_sample_rate(2,400);
	//set_adc_ce(3, 1,adc_ce_reg_pointer);
	
	while (1) {
		int uart_data = usart_getchar(USART3_BASE_ADDR) & 0xFF;						//wait for uart data
80002db6:	6c 0c       	ld.w	r12,r6[0x0]
80002db8:	f0 1f 00 1d 	mcall	80002e2c <main+0x1b0>
80002dbc:	ef dc c0 08 	bfextu	r7,r12,0x0,0x8
		usart_putchar(USART3_BASE_ADDR, uart_data);									//echo back data
80002dc0:	0e 9b       	mov	r11,r7
80002dc2:	6c 0c       	ld.w	r12,r6[0x0]
80002dc4:	f0 1f 00 11 	mcall	80002e08 <main+0x18c>
		//gpio_enable_gpio_pin(AVR32_PIN_PA17);
		spi_write_FPGA(0, 0x80, (uart_data-48));									//write data to LED control reg
80002dc8:	ee ca 00 30 	sub	r10,r7,48
80002dcc:	0a 9b       	mov	r11,r5
80002dce:	08 9c       	mov	r12,r4
80002dd0:	f0 1f 00 18 	mcall	80002e30 <main+0x1b4>
		//usart_putchar(USART2_BASE_ADDR, 0x0D);
		int lidar = getLidar();
80002dd4:	f0 1f 00 18 	mcall	80002e34 <main+0x1b8>
80002dd8:	ce fb       	rjmp	80002db6 <main+0x13a>
80002dda:	00 00       	add	r0,r0
80002ddc:	80 00       	ld.sh	r0,r0[0x0]
80002dde:	2b 64       	sub	r4,-74
80002de0:	80 00       	ld.sh	r0,r0[0x0]
80002de2:	2b 10       	sub	r0,-79
80002de4:	80 00       	ld.sh	r0,r0[0x0]
80002de6:	2a e4       	sub	r4,-82
80002de8:	00 00       	add	r0,r0
80002dea:	00 08       	add	r8,r0
80002dec:	00 00       	add	r0,r0
80002dee:	00 f4       	st.b	--r0,r4
80002df0:	80 00       	ld.sh	r0,r0[0x0]
80002df2:	27 a4       	sub	r4,122
80002df4:	00 00       	add	r0,r0
80002df6:	00 0c       	add	r12,r0
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	33 68       	mov	r8,54
80002dfc:	80 00       	ld.sh	r0,r0[0x0]
80002dfe:	29 7c       	sub	r12,-105
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	28 26       	sub	r6,-126
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	21 04       	sub	r4,16
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	29 00       	sub	r0,-112
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	33 8c       	mov	r12,56
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	21 48       	sub	r8,20
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	33 a4       	mov	r4,58
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	33 bc       	mov	r12,59
80002e1c:	80 00       	ld.sh	r0,r0[0x0]
80002e1e:	22 a0       	sub	r0,42
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	22 b8       	sub	r8,43
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	22 0c       	sub	r12,32
80002e28:	80 00       	ld.sh	r0,r0[0x0]
80002e2a:	24 34       	sub	r4,67
80002e2c:	80 00       	ld.sh	r0,r0[0x0]
80002e2e:	29 50       	sub	r0,-107
80002e30:	80 00       	ld.sh	r0,r0[0x0]
80002e32:	20 d0       	sub	r0,13
80002e34:	80 00       	ld.sh	r0,r0[0x0]
80002e36:	25 38       	sub	r8,83

Disassembly of section .exception:

80003000 <_evba>:
80003000:	c0 08       	rjmp	80003000 <_evba>
	...

80003004 <_handle_TLB_Multiple_Hit>:
80003004:	c0 08       	rjmp	80003004 <_handle_TLB_Multiple_Hit>
	...

80003008 <_handle_Bus_Error_Data_Fetch>:
80003008:	c0 08       	rjmp	80003008 <_handle_Bus_Error_Data_Fetch>
	...

8000300c <_handle_Bus_Error_Instruction_Fetch>:
8000300c:	c0 08       	rjmp	8000300c <_handle_Bus_Error_Instruction_Fetch>
	...

80003010 <_handle_NMI>:
80003010:	c0 08       	rjmp	80003010 <_handle_NMI>
	...

80003014 <_handle_Instruction_Address>:
80003014:	c0 08       	rjmp	80003014 <_handle_Instruction_Address>
	...

80003018 <_handle_ITLB_Protection>:
80003018:	c0 08       	rjmp	80003018 <_handle_ITLB_Protection>
	...

8000301c <_handle_Breakpoint>:
8000301c:	c0 08       	rjmp	8000301c <_handle_Breakpoint>
	...

80003020 <_handle_Illegal_Opcode>:
80003020:	c0 08       	rjmp	80003020 <_handle_Illegal_Opcode>
	...

80003024 <_handle_Unimplemented_Instruction>:
80003024:	c0 08       	rjmp	80003024 <_handle_Unimplemented_Instruction>
	...

80003028 <_handle_Privilege_Violation>:
80003028:	c0 08       	rjmp	80003028 <_handle_Privilege_Violation>
	...

8000302c <_handle_Floating_Point>:
8000302c:	c0 08       	rjmp	8000302c <_handle_Floating_Point>
	...

80003030 <_handle_Coprocessor_Absent>:
80003030:	c0 08       	rjmp	80003030 <_handle_Coprocessor_Absent>
	...

80003034 <_handle_Data_Address_Read>:
80003034:	c0 08       	rjmp	80003034 <_handle_Data_Address_Read>
	...

80003038 <_handle_Data_Address_Write>:
80003038:	c0 08       	rjmp	80003038 <_handle_Data_Address_Write>
	...

8000303c <_handle_DTLB_Protection_Read>:
8000303c:	c0 08       	rjmp	8000303c <_handle_DTLB_Protection_Read>
	...

80003040 <_handle_DTLB_Protection_Write>:
80003040:	c0 08       	rjmp	80003040 <_handle_DTLB_Protection_Write>
	...

80003044 <_handle_DTLB_Modified>:
80003044:	c0 08       	rjmp	80003044 <_handle_DTLB_Modified>
	...

80003050 <_handle_ITLB_Miss>:
80003050:	c0 08       	rjmp	80003050 <_handle_ITLB_Miss>
	...

80003060 <_handle_DTLB_Miss_Read>:
80003060:	c0 08       	rjmp	80003060 <_handle_DTLB_Miss_Read>
	...

80003070 <_handle_DTLB_Miss_Write>:
80003070:	c0 08       	rjmp	80003070 <_handle_DTLB_Miss_Write>
	...

80003100 <_handle_Supervisor_Call>:
80003100:	c0 08       	rjmp	80003100 <_handle_Supervisor_Call>
80003102:	d7 03       	nop

80003104 <_int0>:
80003104:	30 0c       	mov	r12,0
80003106:	fe b0 fa 37 	rcall	80002574 <_get_interrupt_handler>
8000310a:	58 0c       	cp.w	r12,0
8000310c:	f8 0f 17 10 	movne	pc,r12
80003110:	d6 03       	rete

80003112 <_int1>:
80003112:	30 1c       	mov	r12,1
80003114:	fe b0 fa 30 	rcall	80002574 <_get_interrupt_handler>
80003118:	58 0c       	cp.w	r12,0
8000311a:	f8 0f 17 10 	movne	pc,r12
8000311e:	d6 03       	rete

80003120 <_int2>:
80003120:	30 2c       	mov	r12,2
80003122:	fe b0 fa 29 	rcall	80002574 <_get_interrupt_handler>
80003126:	58 0c       	cp.w	r12,0
80003128:	f8 0f 17 10 	movne	pc,r12
8000312c:	d6 03       	rete

8000312e <_int3>:
8000312e:	30 3c       	mov	r12,3
80003130:	fe b0 fa 22 	rcall	80002574 <_get_interrupt_handler>
80003134:	58 0c       	cp.w	r12,0
80003136:	f8 0f 17 10 	movne	pc,r12
8000313a:	d6 03       	rete
8000313c:	d7 03       	nop
8000313e:	d7 03       	nop
80003140:	d7 03       	nop
80003142:	d7 03       	nop
80003144:	d7 03       	nop
80003146:	d7 03       	nop
80003148:	d7 03       	nop
8000314a:	d7 03       	nop
8000314c:	d7 03       	nop
8000314e:	d7 03       	nop
80003150:	d7 03       	nop
80003152:	d7 03       	nop
80003154:	d7 03       	nop
80003156:	d7 03       	nop
80003158:	d7 03       	nop
8000315a:	d7 03       	nop
8000315c:	d7 03       	nop
8000315e:	d7 03       	nop
80003160:	d7 03       	nop
80003162:	d7 03       	nop
80003164:	d7 03       	nop
80003166:	d7 03       	nop
80003168:	d7 03       	nop
8000316a:	d7 03       	nop
8000316c:	d7 03       	nop
8000316e:	d7 03       	nop
80003170:	d7 03       	nop
80003172:	d7 03       	nop
80003174:	d7 03       	nop
80003176:	d7 03       	nop
80003178:	d7 03       	nop
8000317a:	d7 03       	nop
8000317c:	d7 03       	nop
8000317e:	d7 03       	nop
80003180:	d7 03       	nop
80003182:	d7 03       	nop
80003184:	d7 03       	nop
80003186:	d7 03       	nop
80003188:	d7 03       	nop
8000318a:	d7 03       	nop
8000318c:	d7 03       	nop
8000318e:	d7 03       	nop
80003190:	d7 03       	nop
80003192:	d7 03       	nop
80003194:	d7 03       	nop
80003196:	d7 03       	nop
80003198:	d7 03       	nop
8000319a:	d7 03       	nop
8000319c:	d7 03       	nop
8000319e:	d7 03       	nop
800031a0:	d7 03       	nop
800031a2:	d7 03       	nop
800031a4:	d7 03       	nop
800031a6:	d7 03       	nop
800031a8:	d7 03       	nop
800031aa:	d7 03       	nop
800031ac:	d7 03       	nop
800031ae:	d7 03       	nop
800031b0:	d7 03       	nop
800031b2:	d7 03       	nop
800031b4:	d7 03       	nop
800031b6:	d7 03       	nop
800031b8:	d7 03       	nop
800031ba:	d7 03       	nop
800031bc:	d7 03       	nop
800031be:	d7 03       	nop
800031c0:	d7 03       	nop
800031c2:	d7 03       	nop
800031c4:	d7 03       	nop
800031c6:	d7 03       	nop
800031c8:	d7 03       	nop
800031ca:	d7 03       	nop
800031cc:	d7 03       	nop
800031ce:	d7 03       	nop
800031d0:	d7 03       	nop
800031d2:	d7 03       	nop
800031d4:	d7 03       	nop
800031d6:	d7 03       	nop
800031d8:	d7 03       	nop
800031da:	d7 03       	nop
800031dc:	d7 03       	nop
800031de:	d7 03       	nop
800031e0:	d7 03       	nop
800031e2:	d7 03       	nop
800031e4:	d7 03       	nop
800031e6:	d7 03       	nop
800031e8:	d7 03       	nop
800031ea:	d7 03       	nop
800031ec:	d7 03       	nop
800031ee:	d7 03       	nop
800031f0:	d7 03       	nop
800031f2:	d7 03       	nop
800031f4:	d7 03       	nop
800031f6:	d7 03       	nop
800031f8:	d7 03       	nop
800031fa:	d7 03       	nop
800031fc:	d7 03       	nop
800031fe:	d7 03       	nop
